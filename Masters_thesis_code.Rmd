.---
title: "Systemic study of human cell types: Study of the morphological and molecular relationships of cell types using hierarchical clustering"
author: "María José Martínez Martínez"
date: "27/2/2022"
output: pdf_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Save environment
save.image("env.RData")
```



## Import libraries for all sections



```{r}
library(readxl)
library(crayon)
library(umap)
library(factoextra) 
library(dendextend)
library (lessR)
library(Hmisc)
library(cluster) 
library(gridExtra)
library(randomcoloR)
library(ggdendro)
library(FactoMineR)
library(clustermole)
library(CGPfunctions)
library(corrplot)
library(NbClust)
library(fpc)
library(igraph)
library(ggpubr) 
library(reshape2) 
library(rlang) 
library(clustertend) 
library(GGally) 
library(modeest) 
library(RColorBrewer) 
library(DGCA)
library(tidyverse) 
library(ade4) 
library(proxy)
library(vegan) 
library(caret) 
library(kableExtra)
library(e1071) 
library(ontologyIndex)
library(permute)
library(lattice)
library(vegan)
library(hydroGOF) 
```



# 1. Review of single-cell RNAseq data from humans and model organisms of interest for the evolutionary study of cell types



## 1.2. Import data



```{r}
## I load in a dataset from the Human Protein Atlas (https://www.proteinatlas.org). Specifically, I will work on the RNA single cell type tissue cluster data (https://www.proteinatlas.org/about/download). This dataset consists of the normalised gene expression values of ~ 20,000 human protein-coding genes from 444 individual cell type clusters corresponding to 76 different cell types found in 27 major healthy tissues and organs.

df_pTPM_original<- read_tsv("rna_single_cell_type_tissue_version_2_1.tsv", show_col_types = FALSE)
colnames(df_pTPM_original)<- c("Gene", "Gene_name", "Tissue", "Cluster", "Cell_type", "Read_count", "pTPM") # Replace spaces with low bars
df_pTPM_original<- df_pTPM_original %>% mutate(ID= paste(Tissue, Cluster, sep=" ")) # Add new column with tissue and cluster information
```


```{r}
## I load in the library(ies) that may contain information on cell subtype markers or cell type markers per tissue.

# CellMarker databases (see http://bio-bigdata.hrbmu.edu.cn/CellMarker/)
CellMarker_Human_cell_markers<- read.delim("http://bio-bigdata.hrbmu.edu.cn/CellMarker/download/Human_cell_markers.txt")
CellMarker_Single_cell_markers<- read.delim("http://bio-bigdata.hrbmu.edu.cn/CellMarker/download/Single_cell_markers.txt")

CellMarker_df<- rbind(CellMarker_Human_cell_markers, CellMarker_Single_cell_markers)
CellMarker_df<- CellMarker_df %>% filter(speciesType == "Human")
CellMarker_df<- CellMarker_df %>% filter(cancerType == "Normal")


# PanglaoDB database
#PanglaoDB<- read_tsv("PanglaoDB_markers_27_Mar_2020.tsv")
#colnames(PanglaoDB)<- c("species", "official_gene_symbol", "cell_type", "nicknames", "ubiquitousness_index", "product_description",  "gene_type",  "canonical_marker", "germ_layer", "organ", "sensitivity_human", "sensitivity_mouse", "specificity_human", "specificity_mouse")
#PanglaoDB<- PanglaoDB %>% subset(species == "Hs" | species == "Mm Hs") 


# Karlsson et al. (2021) markers
#DataS2_karlsson<- read_excel("sciadv.abh2169_Data_S2.xlsx")
#colnames(DataS2_karlsson)<- c("Tissue", "Cell_type_group", "Cell_type", "Marker")


# Package "clustermole"
#clustermole <- clustermole_markers(species = "hs")
#clustermole<- clustermole %>% subset(species == "Human")
```



## 1.3. Data preparation



```{r}
## I declare variables that will be used throughout the code.


# I group cell types according to Karlsson et al. (2021) (see https://www.proteinatlas.org/humanproteome/single+cell+type)
Adipocytes<-	c("adipocytes")
Blood_and_immune <-	c("t-cells", "b-cells", "plasma cells", "nk-cells", "granulocytes", "monocytes", "macrophages", "hofbauer cells", "kupffer cells", "dendritic cells", "langerhans cells", "erythroid cells")
Endocrine<- c("enteroendocrine cells", "pancreatic endocrine cells", "leydig cells", "theca cells")	
Endothelial <-	c("endothelial cells")
Germ<- c("spermatogonia", "spermatocytes", "early spermatids", "late spermatids")
Glandular_epithelial<- c("basal respiratory cells", "club cells", "ionocytes", "respiratory ciliated cells", "gastric mucus-secreting cells", "proximal enterocytes", "paneth cells", "distal enterocytes", "intestinal goblet cells", "exocrine glandular cells", "basal prostatic cells", "prostatic glandular cells", "breast glandular cells", "breast myoepithelial cells", "endometrial ciliated cells", "glandular and luminal cells")
Glial<- c("astrocytes", "oligodendrocyte precursor cells", "oligodendrocytes", "microglial cells", "muller glia cells")
Mesenchymal<- c("fibroblasts", "hepatic stellate cells", "peritubular cells", "endometrial stromal cells")
mixed_cell_types<- c("mixed cell types")
mixed_immune<- c("mixed immune cells")
Muscle <-	c("cardiomyocytes", "skeletal myocytes", "smooth muscle cells")
Neuronal<-	c("excitatory neurons", "inhibitory neurons", "cone photoreceptor cells", "rod photoreceptor cells", "bipolar cells", "horizontal cells")
Pigment <-	c("melanocytes")
Squamous_epithelial<-	c("basal keratinocytes", "suprabasal keratinocytes", "basal squamous epithelial cells", "squamous epithelial cells")	
Specialized_epithelial<-	c("alveolar cells type 1", "alveolar cells type 2", "ductal cells", "hepatocytes", "cholangiocytes", "proximal tubular cells", "distal tubular cells", "collecting duct cells", "urothelial cells", "sertoli cells", "granulosa cells")	
Trophoblast<-	c("cytotrophoblasts", "syncytiotrophoblasts", "extravillous trophoblasts")
Undifferentiated <-	c("undifferentiated cells")


palette_ctgroups <- c("darkseagreen1", # Adipocytes
            "firebrick3", # Blood_and_immune
            "mediumpurple3", # Endocrine
            "maroon3", # Endothelial (Vascular)
            "skyblue1", # Germ
            "darkorchid4", # glandular_epithelial
            "orange", # Glial
            "chartreuse3", # Mesenchymal
            "orange", # mixed_cell_types
            "brown", # mixed_immune
            "indianred1", # Muscle
            "yellow", # Neuronal
            "peachpuff", # Pigment
            "steelblue4", # Squamous_epithelial
            "turquoise4", # Specialized_epithelial
            "pink", # Trophoblast
            "mediumturquoise" # Undifferentiated
            ) 


palette_tissues <- distinctColorPalette(26)


palette_pTPM<- distinctColorPalette(8)
```


```{r}
## I declare functions that will be used throughout the code.


# This functions creates and adds cell type group column according to Karlsson et al. (2021)
cell_type_group_column<- function(number_clusters, dataframe, number_column, name_dataframe) {
  
  cell_type_group<- c()
  
  for (i in seq(1:number_clusters)){
    
    example<- dataframe[i, number_column]
    
    if (example %in% Adipocytes) {
      cell_type_group<-c(cell_type_group,"Adipocytes")
      }
    
    else if (example %in% Blood_and_immune){
      cell_type_group<-c(cell_type_group,"Blood & immune")
      }
    
    else if (example %in% Endocrine){
      cell_type_group<-c(cell_type_group,"Endocrine cells")
      }
    
    else if (example %in% Endothelial){
      cell_type_group<-c(cell_type_group,"Endothelial cells")
      }
    
    else if (example %in% Glandular_epithelial){
      cell_type_group<-c(cell_type_group,"Glandular epithelial cells")
      }
    
    else if (example %in% Germ){
      cell_type_group<-c(cell_type_group,"Germ cells")
      }
    
    else if (example %in% Glial){
      cell_type_group<-c(cell_type_group,"Glial cells")
      }
    
    else if (example %in% Mesenchymal){
      cell_type_group<-c(cell_type_group,"Mesenchymal cells")
      }
    
    else if (example %in% mixed_cell_types){
      cell_type_group<-c(cell_type_group,"Mixed cell types")
      }
    
    else if (example %in% mixed_immune) {
      cell_type_group<-c(cell_type_group,"Mixed immune cells")
      }
    
    else if (example %in% Muscle) {
      cell_type_group<-c(cell_type_group,"Muscle cells")
      }
    
    else if (example %in% Neuronal) {
      cell_type_group<-c(cell_type_group,"Neuronal cells")
    }
    
    else if (example %in% Pigment) {
      cell_type_group<-c(cell_type_group,"Pigment cells")
    }
    
     else if (example %in% Squamous_epithelial) {
      cell_type_group<-c(cell_type_group,"Squamous epithelial cells")
    }
    
    else if (example %in% Specialized_epithelial) {
      cell_type_group<-c(cell_type_group,"Specialized epithelial cells")
    }
    
     else if (example %in% Trophoblast) {
      cell_type_group<-c(cell_type_group,"Trophoblasts")
     }
    
      else if (example %in% Undifferentiated) {
      cell_type_group<-c(cell_type_group,"Undifferentiated")
    }
    
    cell_type_group<<- cell_type_group
    
  }

  outside<<- cbind(data.frame("Cell_type_group" = cell_type_group, dataframe[,1:length(dataframe),drop=F]))
  assign(name_dataframe, outside, envir = .GlobalEnv)
}








# It creates a pie chart showing all the clusters identified in a given tissue
PieChart <- function(my_tissue, my_title, my_subtitle, my_OuterPallete, my_InnerPallete) {
  
  par(mar = c(5, 0, 4.1, 20.1))
  
  # Outer pie
  
  plot.new()
  outer_pie<- df_pTPM_original %>% subset(Tissue == my_tissue) %>% subset(Gene_name == "UCP1") %>% arrange(Cell_type) 
  ones<- rep(1, nrow(outer_pie))
  outer_pie <- cbind(outer_pie, Count = ones)
  
  pie(outer_pie$Count, 
      labels = outer_pie$Cluster,
      radius = 1,
      cex= 2,
      col = my_OuterPallete,
      border= my_OuterPallete,
      clockwise = TRUE,
      main = my_title,
      cex.main = 2,
      sub=my_subtitle,
      cex.sub = 1, 
      font.sub = 3)
  
  par(new=TRUE)
  
  
  # Inner pie
  
  inner_pie<- df_pTPM_original %>% subset(Tissue == my_tissue) %>% subset(Gene_name == "UCP1") %>% group_by(Cell_type) %>% summarise(cantidad=n())
  piepercent<- round(100*inner_pie$cantidad/sum(inner_pie$cantidad), 1)
  piepercent<- paste(piepercent, "%", sep=" ")
  
  pie(inner_pie$cantidad, 
      labels =  piepercent,
      cex= 1.3,
      radius = 0.5, 
      col = my_InnerPallete,
      border= my_InnerPallete,
      clockwise = TRUE)
  
  par(mar = c(0, 4.1, 4.1, 0))
  
  
  # Add legend
  
  legend_elements<- c()
  
  for (i in seq(1:nrow(outer_pie[5]))) {
    
    legend_elements<- c(legend_elements, outer_pie[i, 5])
    }
  
  legend_elements<- unique(legend_elements)
  
  legend("topright",
       inset =c(-0.56,0),
       legend=legend_elements,
       title= "Cell types",
       inner_pie$Cell_type, # labels
       text.width=0.7,
       fill = my_InnerPallete,
       border = my_InnerPallete,
       xpd= TRUE,
       bty = "n") # remove border

}






# It visualizes clusters belonging to a specific tissue

UMAPTissue<- function(my_tissue) {
  
  UMAP_dataframe %>% ggplot(aes(x=UMAP1, y=UMAP2)) +
  geom_point(size=3, alpha = 0.5, color="gray") +
  geom_point(data=UMAP_dataframe %>% filter(Tissue == my_tissue), 
             size=3, 
             aes(x=UMAP1, y=UMAP2, colour= Cell_type)) +
  labs(x = "UMAP1", y = "UMAP2") + 
  theme(axis.text=element_text(size=15), # size of the axes titles
        axis.title=element_text(size=20)) + # size of the numbers
  theme(legend.title = element_text(size=15),
        legend.position="right",
        legend.text = element_text(size=10)) +
  labs(color="Cell type\n") + # legend title
  labs(title = "UMAP",
       subtitle = paste0(capitalize(my_tissue), "\n\n", collapse=""),
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=40, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=30),
        plot.caption = element_text(hjust = 0, size=15, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) 
  
}










# It visualizes clusters belonging to a specific cell type
UMAPcelltype<- function(my_celltype) {
  
  UMAP_dataframe %>% ggplot(aes(x=UMAP1, y=UMAP2)) +
  geom_point(size=3, alpha = 0.5, color="gray") +
  geom_point(data=UMAP_dataframe %>% filter(Cell_type == my_celltype), 
             size=3, 
             aes(x=UMAP1, y=UMAP2, colour= Tissue)) +
  labs(x = "UMAP1", y = "UMAP2") + 
  theme(axis.text=element_text(size=15), # size of the axes titles
        axis.title=element_text(size=20)) + # size of the numbers
  theme(legend.title = element_text(size=15),
        legend.position="right",
        legend.text = element_text(size=10)) +
  labs(color="Tissue\n") + # legend title
  labs(title = "UMAP",
       subtitle = paste0(capitalize(my_celltype), "\n\n", collapse=""),
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=40, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=30),
        plot.caption = element_text(hjust = 0, size=15, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) 
  
}









# It Visualizes clusters belonging to a specific cell type group
UMAP_ctgroup<- function(my_filter) {
  
  UMAP_dataframe %>% ggplot(aes(x=UMAP1, y=UMAP2)) +
  geom_point(size=3, alpha = 0.5, color="gray") +
  geom_point(data=UMAP_dataframe %>% filter(Cell_type_group == my_filter), 
             size=3,
             aes(x=UMAP1, y=UMAP2, colour= Cell_type)) +
  labs(x = "UMAP1", y = "UMAP2") + 
  theme(axis.text=element_text(size=15), # size of the axes titles
        axis.title=element_text(size=20)) + # size of the numbers
  theme(legend.title = element_text(size=15),
        legend.position="right",
        legend.text = element_text(size=10)) +
  labs(color="Cell type") + # legend title
  labs(title = "UMAP",
       subtitle = paste0(capitalize(my_filter), "\n\n", collapse=""),
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=40, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=30),
        plot.caption = element_text(hjust = 0, size=15, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) 
}

```


```{r}
## I obtain proper data frame: rows = observations (cell types) and columns = variables (genes)


# Create data frame of one column (Cell_type)
df_pTPM<- data.frame(df_pTPM_original$Cell_type[1:444]) # dim(444,1)

# Add gene columns to it:
start<-1
end<-444

for (i in unique(df_pTPM_original$Gene_name)){
    i<-as.list(df_pTPM_original[start:end,7])
    df_pTPM<- cbind(df_pTPM,i) 
    start= start+444
    end=end+444
}

# Name columns
colnames(df_pTPM)<-c("Cell_type",unique(df_pTPM_original$Gene_name))

# Add column "cell type group" 
cell_type_group_column(number_clusters=444, dataframe=df_pTPM, number_column=1, name_dataframe="df_pTPM")

# Add columns ID and tissue
df_pTPM<- cbind(data.frame("ID" = df_pTPM_original$ID[1:444]), df_pTPM[,1:2,drop=F], data.frame("Tissue" = df_pTPM_original$Tissue[1:444]), df_pTPM[,3:length(df_pTPM),drop=F])
df_pTPM<- df_pTPM %>% mutate(ID_2= paste(Cell_type, ID, sep=" ")) %>% relocate(ID_2, .before=ID)

# Split data into data and target datasets
df_pTPM_data<- df_pTPM[,6:20087]
rownames(df_pTPM_data)<- df_pTPM$ID_2
df_pTPM_target<- df_pTPM %>% select(ID, Cell_type_group, Cell_type, Tissue)
```


```{r}
#write.csv(df_pTPM, "df_pTPM.csv")
#write.csv(df_pTPM_data, "df_pTPM_data.csv")
#write.csv(df_pTPM_target, "df_pTPM_target.csv")
```



## 1.4. Exploratory Data Analysis



```{r}
# Check for missing data
any(is.na(df_pTPM_original))

# In case of TRUE, missing data must be removed or estimated
```


```{r}
# Dimensions
cat(bold("Dimensions: \n\n"), bold("Rows: "), nrow(df_pTPM_original), "\n", bold("Columns: "), ncol(df_pTPM_original), "\n\n")

# Information about tissues
tissues <- df_pTPM_original$Tissue
unique_tissues <-unique(tissues)
cat(bold("Number of tissues: "), length(unique_tissues), "\n\n")
cat(bold("Tissues: "), paste0(unique_tissues, collapse=", "), "\n\n")


# Information about cell types
celltypes <- df_pTPM_original$Cell_type
unique_celltypes <- unique(celltypes)
cat(bold("Number of cell types: "), length(unique_celltypes), "\n\n")
cat(bold("Cell types: "), paste0(unique_celltypes, collapse=", "), "\n\n")


# Information about genes
genes<-df_pTPM_original$Gene_name
unique_genes <- unique(genes)
cat(bold("Number of genes: "), length(unique_genes), "\n\n")


# Information about clusters
# A cluster consists of several cells grouped together because they have similar gene expression pattern
# All genes have the same number of clusters per tissue
clusters <- df_pTPM_original %>% subset(Gene_name == "VIM") # for example, VIM
cat(bold("Number of clusters: "), nrow(clusters), "\n\n")
# 444 clusters
```


```{r}
# See if there is any gene whose expression is invariant among the clusters

length(which(apply(df_pTPM_data, 2, function(x) length(unique(x))) == 1))
length(which(apply(df_pTPM, 2, function(x) length(unique(x))) == 1))
# returns number of columns which has number of unique values equal to 1, meaning that has the same value (invariant genes)

# Store their names
genes_discarded1<- names(which(apply(df_pTPM_data, 2, function(x) length(unique(x))) == 1))
genes_discarded2<- names(which(apply(df_pTPM, 2, function(x) length(unique(x))) == 1))
```


```{r}
dim(df_pTPM_data)
dim(df_pTPM)
```


```{r}
# I remove invariant genes because they don't get us any useful information

#df_pTPM_data<- df_pTPM_data[, colSums(df_pTPM_data != 0) > 0] # This option does not consider other non-zero constant values.
df_pTPM_data <- df_pTPM_data[, ! names(df_pTPM_data) %in% genes_discarded1, drop = F]
df_pTPM <- df_pTPM[, ! names(df_pTPM) %in% genes_discarded2, drop = F]

# check that all genes removed corresponds to genes with 0 expression
dim(df_pTPM_data)
dim(df_pTPM)
```


```{r}
## Obtain another proper data frame: rows = observations (genes) and columns = variables (cell types)

df_pTPM_genes<- as.data.frame(t(df_pTPM_data))
```



### 1.4.1. Differential gene expression across clusters


Nule hypothesis (to be confirmed its foundation) --> Genes varying the most between the different clusters (i.e., with very different expression values among clusters) will have the greatest contribution in the first components. On the other hand, a gene whose expression is rather similar in all clusters will contribute with little variance and will, therefore, not be included in the first components. We are interested in genes whose expression is very different between cell types because we assume that these are the ones that provide specificity to the cluster. Genes that are expressed similarly in all clusters should correspond to genes responsible for basic functions (e.g. mitochondria, ribosomes).

This hypothesis can be tested by applying PCA


```{r}
### Using the princomp function to calculate PCA
# prcomp() calculates the PC's by using eigen on the correlation or covariance matrix 

PCA<-princomp(df_pTPM_genes,cor=FALSE,scores=TRUE)
# setting cor=FALSE to use covariance, not correlation
# 'princomp' can only be used with more units than variables
```


```{r}
# Plotting variance explained by each component
plot(PCA, main = "Explained variance per Principal Component")
```


```{r}
# Another way to visualize it
plot(PCA, type = "l", main = "Explained variance per Principal Component")
```


```{r}
# Percentage of variance captured by each component
fviz_eig(PCA, ncp=20, addlabels = TRUE, ylim = c(0, 35))
```


```{r}
# PVE: Proporción de varianza explicada

PVE <- 100*PCA$sdev^2/sum(PCA$sdev^2)

par(mfrow = c(1,2))

plot(PVE, type = "o", 
     ylab = "PVE", 
     xlab = "Componente principal", 
     col = "blue")
plot(cumsum(PVE), type = "o", 
     ylab = "PVE acumulada", 
     xlab = "Componente principal", 
     col = "brown3")
```


```{r}
# Row names of PCA loadings:
row.names(PCA$loadings[1:20, 1:2]) # first 20 loadings names (clusters)
```


```{r}
PCA$loadings[1:20, 1:2] # first 20 loadings (clusters)
```


```{r}
# To improve the understanding of the visualization, I am renaming the labels
pca_labels <- colnames(df_pTPM_genes)
```


```{r}
# Plotting the loadings for the first two components (the most significant)
plot(PCA$loadings[, 1:2], main = "Variability of each sample across PC 1 and 2")
text(PCA$loadings[, 1:2],
     labels=pca_labels)
```


I am going to extract the top and bottom 5,000 scores for the first principal component (the first component explains most of the variability):


```{r}
# Sorting scores by the PC1 (column 1)
sorted_scores1 <- sort(PCA$scores[,1])
```


```{r}
# The lowest scores (more negative) are obtained with head
lowest_scores1 <- head(sorted_scores1, 5000)

# The highest scores (more positive) are obtained with tail
highest_scores1 <- tail(sorted_scores1, 5000)
```


```{r}
# Selecting the data corresponding to those genes (with their names)
# converting it to matrix to use it in heatmap
low_data1 <- as.matrix(df_pTPM_genes[names(lowest_scores1), ])
high_data1 <- as.matrix(df_pTPM_genes[names(highest_scores1), ])

# changing them so that they are the same as in the PCA loadings
colnames(low_data1) <- pca_labels
colnames(high_data1) <- pca_labels
```


```{r}
### Heatmaps, PC1:

# Lowest scores
heatmap(low_data1, main = "Heatmap, lowest scoring genes, PC 1",
        margins = c(7, 2))

# Highest scores
heatmap(high_data1, main = "Heatmap, highest scoring genes, PC 1",
        margins = c(7, 2))
```


I am going to extract the top and bottom 5,000 scores for the first and second principal components:


```{r}
# Sorting scores by the PC2 (column 2)
sorted_scores2 <- sort(PCA$scores[,2])

```


```{r}
# The lowest scores (more negative) are obtained with head
lowest_scores2 <- head(sorted_scores2, 5000)

# The highest scores (more positive) are obtained with tail
highest_scores2 <- tail(sorted_scores2, 5000)

```


```{r}
# Merging both names (from PC 1 and PC 2) and deleting duplicates
lowest_scoring_genes_1_2 <- unique(c(names(lowest_scores1), names(lowest_scores2)))

highest_scoring_genes_1_2 <- unique(c(names(highest_scores1), names(highest_scores2)))
```


```{r}
# Selecting the data corresponding to those genes (with their names)
# converting it to matrix to use it in heatmap
low_data12 <- as.matrix(df_pTPM_genes[lowest_scoring_genes_1_2, ])
high_data12 <- as.matrix(df_pTPM_genes[highest_scoring_genes_1_2, ])

# changing them so that they are the same as in the PCA loadings
colnames(low_data12) <- pca_labels
colnames(high_data12) <- pca_labels
```


```{r}
### Heatmaps, PC1 and PC2:

# Lowest scores
heatmap(low_data12, main = "Heatmap, lowest scoring genes, PC 1 and 2",
        margins = c(7, 2))

# Highest scores
heatmap(high_data12, main = "Heatmap, highest scoring genes, PC 1 and 2",
        margins = c(7, 2))
```



### 1.4.2. Basic statistics



```{r}
# Media de la expresión de cada gen (muestra de los 10 primeros)
# (MARGIN = 2 para que se aplique la función a las columnas)
apply(X = df_pTPM_data, MARGIN = 2, FUN = mean)[1:10]
```


```{r}
# Varianza de la expresión de cada gen (muestra de los 10 primeros)
apply(X = df_pTPM_data, MARGIN = 2, FUN = var)[1:10]
```

```{r}
# Standard deviation de la expresión de cada gen (muestra de los 10 primeros)
apply(X = df_pTPM_data, MARGIN = 2, FUN = sd)[1:10]
```



#### 1.4.2.1. Distribution of genes


```{r}
# Plot gene expression dispersion per cluster

partI<- df_pTPM_genes[,1:222]
partII<- df_pTPM_genes[,223:444]

boxplot(partI, main = "Distribution of gene expression values per cluster",
        xlab = "Cell type", ylab = "Gene expression", cex.axis = 0.75, las = 2, ylim = c(0, 400000))

boxplot(partII, main = "Distribution of gene expression values per cluster",
        xlab = "Cell type", ylab = "Gene expression", cex.axis = 0.75, las = 2,  ylim = c(0, 400000))
```


Para saber si los genes siguen una distribution normal, hacemos el test de normalidad de Shapiro-Wilk:


```{r}
## Shapiro-Wilk normality test
# Se utiliza un nivel de significación de 0,05.
# H0 : p-value < 0.05 (no se trata de una distribcuión normal)
# H1 : p-value < 0.05 (es una distribcuión normal)

genes<- colnames(df_pTPM_data)
p_values<- c()

for (i in seq_along(genes)) {
  
  A<- shapiro.test(df_pTPM_data[,i])
  p_values<- c(p_values, A$p.value)
  
}


## According to X:
# if p-valor < 0.05, we discard normality

target<- c()

for (i in seq_along(p_values)){
  
  if (p_values[i] < 0.05) {
    target<- c(target, "Non-normal distribution")
  } 
  
  else {
    target<- c(target, "Normal distribution")
  }
}


# Add target column
df_SW<- data.frame(genes, p_values, target)
df_SW<- transform(df_SW, target=as.factor(target))

# Visualize number of cases for each condition (normal and non-normal distribution)
table(df_SW$target)
```


```{r}
## Check visually
# I can't plot the distribution of the ~20,000 variables (=genes), so I will have a look to 20 andom genes

# Get random genes
colnames_df_pTPM_data<- colnames(df_pTPM_data)
set.seed(123)
genes_sample<- sample(colnames_df_pTPM_data, 20)

# Get their pTPM values
data <- subset(df_pTPM_data, select = genes_sample) 
mdat <- melt(data)

# Get their gene expression means
cdat <- plyr::ddply(mdat, "variable", summarise, value.mean=mean(value))


# Plot frequency histogram, with a line for the mean
ggplot(mdat, aes(x = value)) + 
   geom_histogram(binwidth=.5, colour="black", fill="white") +
  geom_vline(data=cdat, aes(xintercept=value.mean), linetype="dashed", size=1, colour="red") +
  labs(x = "Ranges", y = "Frequency") + 
  theme(axis.text.x=element_text(size=10), 
        axis.text.y=element_text(size=10),
        axis.title=element_text(size=20)) + # size of the numbers
  theme(legend.title = element_text(size=19),
        legend.position="right",
        legend.text = element_text(size=17)) +
  labs(title = "Frequency histogram",
       subtitle = "We can visualise the distribution of a single continuous variable by dividing the X-axis into bins and counting the number of observations in each bin.\nThe dashed red line corresponds to the mean\n",
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=30, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=15),
        plot.caption = element_text(hjust = 1, size=10, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  facet_wrap(~variable, scales="free")
```



```{r}
# Function to plot any gen's distribution
# For example, VIM

plot_distribution<- function(my_gene = "VIM") {
  
  df_pTPM_original %>% 
  filter(Gene_name == my_gene) %>%
  ggplot(., aes(x = pTPM)) + 
  geom_histogram(aes(y=..density..), colour="black", fill="white") +
  geom_density(alpha=.2, fill="#FF6666") +
  geom_vline(aes(xintercept=mean(pTPM)), color="red", linetype="dashed", size=1) +
  labs(x = "Ranges", y = "Frequency") + 
  theme(axis.text.x=element_text(size=10), 
        axis.text.y=element_text(size=10),
        axis.title=element_text(size=20)) + # size of the numbers
  theme(legend.title = element_text(size=19),
        legend.position="right",
        legend.text = element_text(size=17)) +
  labs(title = my_gene,
       subtitle = "The dashed red line corresponds to the mean\n",
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=30, face = "bold"),
        plot.subtitle = element_text(hjust = 1, size=15),
        plot.caption = element_text(hjust = 1, size=10, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"))
}
```


```{r}
plot_distribution()
```


```{r}
# Density plot: compare the distribution of a particular gene expression across tissues
# For example, VIM
df_pTPM_original %>%
  filter(Gene_name == 'UCP1') %>%
  filter(Cell_type == 'adipocytes') %>%
  ggplot(., aes(x = pTPM, fill = Tissue)) +
  geom_density(alpha = 0.3) +
  scale_fill_manual("Tissue", values = palette_tissues) +
  labs(x = "pTPM", y = "Distribution") + 
  theme(axis.text.x=element_text(size=10), 
        axis.text.y=element_text(size=20),
        axis.title=element_text(size=20)) + # size of the numbers
  theme(legend.title = element_text(size=19),
        legend.position="right",
        legend.text = element_text(size=17)) +
  labs(title = "UCP1 - adipocytes\n",
       subtitle = "Density plot showing the distribution of the VIM gene expression across all cell types\n\n",
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=45, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=20),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"))
```



#### 1.4.2.2. Correlation between cell types



```{r}
# computes a matrix of Pearson's r or Spearman's rho rank correlation coefficients for all possible pairs of columns of a matrix
cor_ct<- rcorr(as.matrix(df_pTPM_genes), type=c("spearman"))
```


```{r}
str(cor_ct)
```


```{r}
# Store rho and p values
cor_ct_r=data.frame(cor_ct$r) # I will only consider the rho value
cor_ct_p=data.frame(cor_ct$P)
```


```{r}
# Remove diagonal with zeros and all data above
cor_ct_r[upper.tri(cor_ct_r)] <- NA
diag(cor_ct_r) <- NA

# Melt data frate
cor_ct_r<- melt(as.matrix(cor_ct_r))

# Remove NA's
cor_ct_r<- na.omit(cor_ct_r)
```


```{r}
## According to https://geographyfieldwork.com/SpearmansRankCalculator.html:
# 0.00 to 0.19	A very weak correlation
# 0.20 to 0.39	A weak correlation
# 0.40 to 0.69	A moderate correlation
# 0.70 to 0.89	A strong correlation
# 0.90 to 1.00	A very strong correlation

var_1<- rownames(cor_ct_r)
Target<- c()

for (i in seq_along(var_1)){
  
  if (cor_ct_r$value[i] < 0.2) {
    Target<- c(Target, "very weak")
  } 
  
  if (cor_ct_r$value[i] >= 0.2 & cor_ct_r$value[i] < 0.4) {
    Target<- c(Target, "weak")
  } 
  
  if (cor_ct_r$value[i] >= 0.4 & cor_ct_r$value[i] < 0.7) {
    Target<- c(Target, "moderate")
  } 
  
  if (cor_ct_r$value[i] >= 0.7 & cor_ct_r$value[i] < 0.9) {
    Target<- c(Target, "strong")
  }
  
  if (cor_ct_r$value[i] >= 0.9 & cor_ct_r$value[i] <= 1) {
    Target<- c(Target, "very strong")
  }
}

# Add target column
cor_ct_r<- cbind(cor_ct_r, Target)
cor_ct_r<- transform(cor_ct_r, Target=as.factor(Target))

# See default levels order:
levels(cor_ct_r$Target) 
# "Good", "Not good", "Reasonably good", "Very good" 

# Specify the factor levels in the order I want
cor_ct_r$Target <- factor(cor_ct_r$Target, levels = c("very weak", "weak", "moderate", "strong", "very strong"))

# Visualize number of cases for each condition (strength correlation)
table(cor_ct_r$Target)
```


Con estos datos, podemos buscar en la tabla clusters que cuya expresión se correlacione mucho o poco, y plotearlos:


```{r}
## Correlation between cell types
# excitatory neurons vs inhibitory neurons

x <- df_pTPM_genes[, c("excitatory neurons brain c-1")]
y <- df_pTPM_genes[, c("inhibitory neurons brain c-5")]

plot(x, y, main = "excitatory vs inhibitory neurons",
 xlab = "excitatory neurons", ylab = "inhibitory neurons",
 pch = 19)
```


```{r}
## Correlation between cell types
# excitatory neurons vs adipocytes

x <- df_pTPM_genes[, c("adipocytes adipose tissue c-11")]
y <- df_pTPM_genes[, c("inhibitory neurons brain c-5")]

plot(x, y, main = "adipocytes vs inhibitory neurons",
 xlab = "adipocytes", ylab = "inhibitory neurons",
 pch = 19)
```



### 1.4.3. Number of tissues per cell type



```{r}
df_ntpct<- df_pTPM_original %>% subset(Gene_name  == "VIM") %>% select("Tissue", "Cell_type") # all clusters

unique_celltypes<- unique(df_ntpct$Cell_type) # list of the cell types

final_df<- c() # empty vector
  
for (i in unique_celltypes){ 
  
  celltypes_lowbars<-gsub(" ","_", i) # replace the spaces in the tissue name with low bars
  celltypes<- i #store the new cell type names
    
  df_i<- df_ntpct %>% subset(Cell_type == i) # data frame with info about the cell type and the tissues where it occurs
    
  tissues_i<- unique(df_i$Tissue) # unique tissues
  number_tissues_i<- length(tissues_i) # number of tissues
    
  row<- c(celltypes, number_tissues_i) # vector with 2 elements: cell type, number of tissues
  final_df<- rbind(final_df,row)
    
  final_df<- as.data.frame(final_df) # convert to data frame
  colnames(final_df)<- c("Cell_type", "Number_Unique_Tissues")
    
  # final_df is a data frame whose columns are of type character. I need to convert the second column to numeric
  final_df<- transform(final_df,Number_Unique_Tissues = as.numeric(Number_Unique_Tissues)) 
  final_df<- arrange(final_df, desc(Number_Unique_Tissues)) # order numbers
    
  rownames(final_df)<- c(seq(1:length(final_df$Cell_type))) # change rownames to numbers
    
  outside<<- final_df
  assign("df_pTPM_original_tissues_per_ct", outside, envir = .GlobalEnv) # change the variable's name for the one introduced when calling the function
    
  # Show a list of cell types present in each tissue
  tissues_i<-paste0(tissues_i, collapse=", ")
  cat(bold(i, ":"), tissues_i, "\n\n")
    
}

cat(bold$underline("\n\n"))

number_tissues_all_celltypes<- unique(final_df[,2])
  
for (i in number_tissues_all_celltypes){
  
  same_nt_df<-c()
  same_nt_df<-final_df %>% filter(Number_Unique_Tissues == i) # filter by same number of tissues
  celltypes_same_tissues<- same_nt_df$Cell_type # cell types with the same number of tissues
    
  cat(bold("Celltypes occurring in", i, "tissues:"), paste0(celltypes_same_tissues,collapse=", "), "\n\n")
  
  }
```



```{r}
# Data preparation for visualization
ones_444<- rep(1, 444)

df_tissues_per_celltype<- df_pTPM_original %>% subset(Gene_name == "VIM") %>% select("Tissue", "Cell_type") # for example, VIM
df_tissues_per_celltype <- cbind(df_tissues_per_celltype, Count = ones_444)
df_tissues_per_celltype<- df_tissues_per_celltype[!duplicated(df_tissues_per_celltype), ]
df_tissues_per_celltype<- df_tissues_per_celltype %>% group_by(Cell_type) %>% mutate(suma=n()) %>% arrange(desc(suma))
```


```{r}
# Barplot

#tiff("tissues_per_ct.tiff",width=3840,height=2160)

ggplot(df_tissues_per_celltype, aes(fill=Tissue, x=Count, y=fct_inorder(Cell_type))) +
  scale_color_manual(values=palette_tissues) + 
  scale_fill_manual(values=palette_tissues) +
  geom_bar(stat='identity', position='stack', width=0.9, alpha=.8) +
  labs(x = "\nNumber of tissues", y = "Cell types\n") + 
  scale_x_continuous(breaks=seq(0,17,by=1)) + # X-axis scale
  theme(axis.text=element_text(size=10), 
        axis.title=element_text(size=20)) + 
  theme(legend.title = element_text(size=15),
        legend.position="right",
        legend.text = element_text(size=10)) +
  labs(fill="26 Tissues") + # legend title
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"),
        axis.ticks.x = element_blank())

#dev.off()
```



### 1.4.4. Number of cell types per tissue



```{r}
df_nctpt<- df_pTPM_original %>% subset(Gene_name  == "VIM") %>% select("Tissue", "Cell_type") # all clusters
unique_tissues<- unique(df_nctpt$Tissue) # list of the tissues
  
final_df<- c() # empty vector
  
for (i in unique_tissues){ 
    
  tissues_lowbars<-gsub(" ","_", i) # replace the spaces in the tissue name with low bars
  tissues<- i #store the new tissue names
    
  df_i<- df_nctpt %>% subset(Tissue == i) # data frame with infor about the tissue and its cell types (repeated)
    
  celltypes_i<- unique(df_i$Cell_type) # unique cell types
  number_celltypes_i<- length(celltypes_i) # number of unique cell types
    
  row<- c(tissues, number_celltypes_i) # vector with 2 elements: tissue, number of cell types
  final_df<- rbind(final_df,row)
    
  final_df<- as.data.frame(final_df) # convert to data frame
  colnames(final_df)<- c("Tissue", "Number_Unique_Cell_types")
    
  # final_df is a data frame whose columns are of type character. I need to convert the second column to numeric
  final_df<- transform(final_df,Number_Unique_Cell_types = as.numeric(Number_Unique_Cell_types)) 
  final_df<- arrange(final_df, desc(Number_Unique_Cell_types)) # order numbers
    
  rownames(final_df)<- c(seq(1:length(final_df$Tissue))) # change rownames to numbers
    
  outside<<- final_df
  assign("df_pTPM_original_ct_per_tissue", outside, envir = .GlobalEnv) # change the variable's name for the one introduced when calling the function
    
  # Show a list of cell types present in each tissue
  celltypes_i<-paste0(celltypes_i, collapse=", ")
  cat(bold(i, ":"), celltypes_i, "\n\n")
    
  }
  
cat(bold$underline("\n\n"))
  
number_ct_all_tissues<- unique(final_df[,2])
  
for (i in number_ct_all_tissues){
  
  same_nct_df<-c()
  same_nct_df<-final_df %>% filter(Number_Unique_Cell_types == i) # filter by same number of cell types
  tissues_same_nct<- same_nct_df$Tissue # tissues with the same number of cell types
    
  cat(bold("Tissues with", i, "cell types:"), paste0(tissues_same_nct,collapse=", "), "\n\n")
    
}
```


```{r}
# Data preparation for visualization


df_celltypes_per_tissue<- df_pTPM_original %>% subset(Gene_name == "VIM") %>% select("Tissue", "Cell_type") # for example, VIM
df_celltypes_per_tissue <- cbind(df_celltypes_per_tissue,Count=ones_444)
cell_type_group_column(number_clusters=444, dataframe=df_celltypes_per_tissue, number_column=2, name_dataframe="df_celltypes_per_tissue")

df_celltypes_per_tissue<- df_celltypes_per_tissue[!duplicated(df_celltypes_per_tissue), ]
df_celltypes_per_tissue<- df_celltypes_per_tissue %>% group_by(Tissue) %>% mutate("suma"=n()) %>% arrange(desc(suma))
```


```{r}
# Barplot
set.seed(123)
palette_ct <- distinctColorPalette(17)


#tiff("ct_per_tissue.tiff",width=3840,height=2160)

ggplot(df_celltypes_per_tissue, aes(fill=Cell_type_group, y=fct_inorder(Tissue), x=suma)) +
  scale_color_manual(values=palette_ctgroups) + 
  scale_fill_manual(values=palette_ctgroups) +
  geom_bar(stat='identity', position='stack', width=0.7, alpha=.8) +
  labs(x = "\nNumber of cell types", y = "Tissues\n") + 
  scale_x_continuous(breaks=seq(0,10,by=1)) + # X-axis scale
  theme(axis.text=element_text(size=17), 
        axis.title=element_text(size=20)) + 
  theme(legend.title = element_text(size=20),
        legend.position="right",
        legend.text = element_text(size=15)) +
  labs(fill="17 Cell type groups according to\nKarlsson et al. (2021)") + # legend title
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"),
        axis.ticks.x = element_blank())

#dev.off()
```



```{r}
# Get percentage of cell types per tissue

df_celltypes_per_tissue_pct<- df_celltypes_per_tissue %>% select(2, 5)
df_celltypes_per_tissue_pct<- distinct(df_celltypes_per_tissue_pct) # remove duplicities

pct<- c()

for (i in df_celltypes_per_tissue_pct$suma) {
  
  A<- round(100*i/length(unique_celltypes),1)
  pct<- c(pct, A)
  
}

df_celltypes_per_tissue_pct<- cbind(df_celltypes_per_tissue_pct, pct)
colnames(df_celltypes_per_tissue_pct)<- c("Tissue", "suma", "pct")
```


```{r}
# Barplot

ggplot(df_celltypes_per_tissue_pct, aes(Tissue,pct)) +
  geom_col() +
  coord_flip() +
  geom_text(aes(label = pct), nudge_y= -3, color="white") +
  labs(x = "%", y = "Tissues") + 
  theme(axis.text=element_text(size=17), 
        axis.title=element_text(size=20)) + 
  labs(title = "Percetange of cell types per tissue\n",
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=30, face = "bold"),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  scale_y_continuous(breaks=seq(0,100,by=20)) # X-axis scale

```



### 1.4.5. Number of clusters per cell type



```{r}
# Data preparation for visualization

df_clusters_per_celltype<- df_pTPM_original %>% subset(Gene_name == "VIM") %>% select("Tissue", "Cluster", "Cell_type") # for example, VIM
df_clusters_per_celltype <- cbind(df_clusters_per_celltype, Count = ones_444)
df_clusters_per_celltype<- df_clusters_per_celltype[!duplicated(df_clusters_per_celltype), ]
df_clusters_per_celltype<- df_clusters_per_celltype %>% group_by(Cell_type) %>% mutate(suma=n()) %>% arrange(desc(suma))
```


```{r}
# Barplot 

#tiff("clusters_per_ct.tiff",width=3840,height=2160)

ggplot(df_clusters_per_celltype, aes(fill=Tissue, x=Count, y=fct_inorder(Cell_type))) +
  scale_color_manual(values=palette_tissues) + 
  scale_fill_manual(values=palette_tissues) +
  geom_bar(stat='identity', position='stack', width=0.9, alpha=.8) +
  labs(x = "\nNumber of clusters", y = "Cell types\n") + 
  scale_x_continuous(breaks=seq(0,46,by=1)) + # X-axis scale
  theme(axis.text=element_text(size=10), 
        axis.title=element_text(size=20)) + 
  theme(legend.title = element_text(size=15),
        legend.position="right",
        legend.text = element_text(size=10)) +
  labs(fill="26 Tissues") + # legend title
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"),
         axis.ticks.x = element_blank())

#dev.off()
```


### 1.4.6. Number of clusters per tissue


```{r}
# Data preparation for visualization

df_clusters_per_tissue<- df_pTPM_original %>% subset(Gene_name == "VIM") %>% select("Tissue", "Cluster", "Cell_type") # for example, VIM
df_clusters_per_tissue <- cbind(df_clusters_per_tissue, Count = ones_444)
cell_type_group_column(number_clusters=444, dataframe=df_clusters_per_tissue, number_column=3, name_dataframe="df_clusters_per_tissue")
df_clusters_per_tissue<- df_clusters_per_tissue %>% group_by(Tissue) %>% mutate(suma=n()) %>% arrange(desc(suma))
```


```{r}
# Barplot

#tiff("clusters_per_tissue.tiff",width=3840,height=2160)

ggplot(df_clusters_per_tissue, aes(fill=cell_type_group, x=Count, y=fct_inorder(Tissue))) +
  scale_color_manual(values=palette_ctgroups) + 
  scale_fill_manual(values=palette_ctgroups) +
  geom_bar(stat='identity', position='stack', width=0.9, alpha=.8) +
  labs(x = "\nNumber of clusters", y = "Tissues\n") + 
  scale_x_continuous(breaks=seq(0,45,by=1)) + # X-axis scale
  theme(axis.text=element_text(size=15), 
        axis.title=element_text(size=20)) + 
  theme(legend.title = element_text(size=20),
        legend.position="right",
        legend.text = element_text(size=15)) +
  labs(fill="17 Cell type groups") + # legend title
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"),
        axis.ticks.x = element_blank())


#dev.off()
```


```{r}
prueba_1<- as.data.frame(table(df_pTPM$Cell_type_group))
prueba_1_percentage<- as.data.frame(prop.table(table(df_pTPM$Cell_type_group)))

ggplot(data=prueba_1, aes(x=Var1, y=Freq)) +
  geom_bar(stat="identity") + 
  coord_flip()

ggplot(data=prueba_1_percentage, aes(x=Var1, y=Freq)) +
  geom_bar(stat="identity") + 
  coord_flip()
```

```{r}
prueba_2<- as.data.frame(table(df_pTPM$`Cell_type`, df_pTPM$Tissue))
prueba_2_percentage<- as.data.frame(prop.table(table(df_pTPM$`Cell_type`, df_pTPM$Tissue)))

ggplot(data=prueba_2, aes(x=Var1, y=Freq)) +
  geom_bar(stat="identity") + 
  coord_flip()

ggplot(data=prueba_2_percentage, aes(x=Var1, y=Freq)) +
  geom_bar(stat="identity") + 
  coord_flip()
```


### 1.4.7. Dimensionality reduction


#### 1.4.7.1. UMAP


Regarding the reproducibility of UMAP, by setting a random_state we are effectively turning off any of the multi-threading that does not support explicit reproducibility. We can check if this parameter works by using the function all.equal(), which compares data frames and returns a TRUE if they both are exactly the same.



```{r}
## Apply UMAP

UMAP_object <- umap(df_pTPM_data, random_state=123)

UMAP_dataframe <- data.frame(UMAP1 = UMAP_object$layout[,1],
                 UMAP2 = UMAP_object$layout[,2],
                 Cell_type = df_pTPM_target$Cell_type,
                 Cell_type_group = df_pTPM_target$Cell_type_group,
                 Tissue = df_pTPM_target$Tissue)
```


```{r}
# Visualize UMAP

ggplot(UMAP_dataframe, aes(x=UMAP1, y=UMAP2)) +
  geom_point(size=4, alpha = 0.8) +
  labs(x = "UMAP1", y = "UMAP2") + 
  theme(axis.text=element_text(size=15), # size of the axes titles
        axis.title=element_text(size=20)) + # size of the numbers
  labs(title = "UMAP\n",
       subtitle = "Uniform Manifold Approximation and Projection (UMAP) is a dimension reduction technique that can be used for visualisation similarly\nto t-SNE, but also for general non-linear dimension reduction.\n\n",
       caption = "\n\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=30, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=20),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"))
```


```{r}
# Visualize UMAP, incorporate cell type groups information

#tiff("UMAP_17_ct_groups.tiff",width=3840,height=2160)

ggplot(UMAP_dataframe, aes(x=UMAP1, y=UMAP2, color=Cell_type_group)) +
  scale_color_manual(values=palette_ctgroups) + # add my own color pallet
  geom_point(size=4, alpha = 0.8) +
  labs(x = "UMAP1", y = "UMAP2") + 
  theme(axis.text=element_text(size=20), # size of the axes titles
        axis.title=element_text(size=30)) + # size of the numbers
  theme(legend.title = element_text(size=19),
        legend.position="right",
        legend.text = element_text(size=17)) +
  labs(color="17 cell type groups") + # legend title
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor=element_blank(), 
        panel.background=element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid"))

#dev.off()
```



```{r}
# Distance between UMAP elements

UMAP_dataframe_data<- UMAP_dataframe[, 1:2]
UMAP_dist <- get_dist(UMAP_dataframe_data, method = "euclidean")
```


```{r}
# Visualize UMAP distance matrix

#png("UMAP_distance_matrix1.png",width=1920,height=1080)
#tiff("AAAA.tiff",width=3840,height=2160)

fviz_dist(UMAP_dist, show_labels = TRUE, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07")) + 
  labs(title = "UMAP") + 
  theme(plot.title = element_text(hjust = 0, size=15, face = "bold"), axis.text = element_text(size = 6),
        axis.text.x=element_text(size=3, angle = 90), 
        axis.text.y=element_text(size=3))

#dev.off()
```


```{r}
# Create data frame with sorted distances

# Convert distance matrix into a matrix
UMAP_dm<- as.matrix(UMAP_dist)

# Name rows and columns
df_pTPM<- df_pTPM %>% mutate(ID_2= paste(ID, Cell_type, Cell_type_group, sep=" "))
colnames(UMAP_dm)<- df_pTPM$ID_2
rownames(UMAP_dm)<- df_pTPM$ID_2
# Remove that column
df_pTPM <- select(df_pTPM, -ID_2)

# Make a copy
UMAP_dm_cp<- duplicate(UMAP_dm, shallow = FALSE)

# Remove diagonal with zeros and all data above
UMAP_dm_cp[upper.tri(UMAP_dm_cp)] <- NA
diag(UMAP_dm_cp) <- NA

# Melt
df_UMAP_distances<- melt(UMAP_dm_cp)
colnames(df_UMAP_distances)<- c("Cluster_1", "Cluster_2", "Distance")
df_UMAP_distances<- na.omit(df_UMAP_distances)
df_UMAP_distances <- df_UMAP_distances[order(df_UMAP_distances$Distance, decreasing = FALSE), ]
```


```{r}
## Search for the distance between two specific clusters

# tissue (e.g., "lymph node")
# cluster (e.g., "c-4")
# cell type (e.g., "b-cells")
# cell type group (e.g., "Blood & immune")

find_dist_UMAP<- function(my_cluster1 = "", my_cluster2 = "") {
  
  df_a1<- as.data.frame(df_UMAP_distances[str_which(df_UMAP_distances$Cluster_1, my_cluster1), ])
  df_a2<- as.data.frame(df_a1[str_which(df_a1$Cluster_2, my_cluster2), ])
  
  df_b1<- as.data.frame(df_UMAP_distances[str_which(df_UMAP_distances$Cluster_1, my_cluster2), ])
  df_b2<- as.data.frame(df_b1[str_which(df_b1$Cluster_2, my_cluster1), ])
  
  df_a_b<-rbind(df_a2, df_b2)
  
  if (nrow(df_a_b) == 1) {
    cat("Distance between", my_cluster1,"and", my_cluster2, ":\n\n")
    df_a_b[1,3]
   } else {
     print(df_a_b)
  }
  
}

find_dist_UMAP(my_cluster1 = "stomach c-0 b-cells Blood & immune", my_cluster2 = "lymph node c-4 b-cells Blood & immune")
```


Las células neuronales parecen ser las que mejor se distinguen, forman un cluster muy cohesionado (elementos del mismo cluster muy cercanos entre sí) y separado de los demá, salvo por unas pocas excepciones.


```{r}
find_dist_UMAP(my_cluster1 = "Neuronal cells", my_cluster2 = "Neuronal cells")
```


```{r}
# Visualize clusters belonging to a specific cell type group

UMAP_ctgroup(my_filter="Adipocytes")
```


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("macrophages")
```


```{r}
# Visualize clusters belonging to a specific tissue

UMAPTissue(my_tissue="adipose tissue")
```



#### 1.4.7.2. PCA 



```{r}
# Compute PCA
# PCA is affected by scale, so you need to scale the features in your data before applying PCA (mean = 0 and standard deviation = 1)
res.pca <- prcomp(df_pTPM_data, scale = TRUE)
# prcomp() not scale by default
```


```{r}
names(res.pca)
```


```{r}
dim(res.pca$rotation)
```


Hay un total de 444 componentes principales distintas, ya que en general pueden haber min(n−1,p) componentes en un set de datos n×p.


```{r}
# Scores vectors
head(res.pca$x)[,1:5]
```


```{r}
# Eigenvalues measure the amount of variation retained by each principal component.
# The sum of all the eigenvalues give a total variance of 1
# Plotting variance explained by each component
plot(res.pca, main = "Explained variance per Principal Component")
```


```{r}
# Another way to plot variance
plot(res.pca, type = "l", main = "Explained variance per Principal Component")
```


```{r}
# Plotting the percentage of variance captured by each component
fviz_eig(res.pca, ncp=12, addlabels = TRUE, ylim = c(0, 100))
```


```{r}
# Eigenvalues, with information about variance percentage and cumulative variance percentage per principal component
eig.val <- get_eigenvalue(res.pca)
eig.val
```


```{r}
# Top 10 variables that contrinute the most to PC1
fviz_contrib(res.pca, choice = "var", axes = 1, top = 100)

# The dashed red line indicates the average contribution value. For a given component, a variable with a contribution greater than this limit can be considered important in contributing to this component.
```


```{r}
# Top 10 variables that contrinute the most to PC2
fviz_contrib(res.pca, choice = "var", axes = 2, top = 100)

# The dashed red line indicates the average contribution value. For a given component, a variable with a contribution greater than this limit can be considered important in contributing to this component.
```


```{r}
fviz_contrib(res.pca, choice = "var", axes = 1:2, top = 100)
```


```{r}
## We can access variance, proportion of variance and cumulative proportion from the standard deviation:

# Standard deviation of each component
#res.pca$sdev

# Variance (= the square of the standard deviation) explained by each component
# Eigenvalues
#res.pca$sdev^2

# The proportion of variance (= the variance divided by the sum of all variances) explained by each component
#res.pca$sdev^2 / sum(res.pca$sdev^2)


# The Cumulative Proportion (= the cumulative sum of the proportion of variance) explained by each component
#cumsum(res.pca$sdev^2 / sum(res.pca$sdev^2))
plot(cumsum(res.pca$sdev^2 / sum(res.pca$sdev^2)), type="b") 
# X: Components, y: Cumulative variance
```


```{r}
# As expected, explained variance is greater in the first component comparing to the following ones
#summary(res.pca)
```


```{r}
# PVE: Proporción de varianza explicada

PVE <- 100*res.pca$sdev^2/sum(res.pca$sdev^2)

par(mfrow = c(1,2))

plot(PVE, type = "o", 
     ylab = "PVE", 
     xlab = "Componente principal", 
     col = "blue")
plot(cumsum(PVE), type = "o", 
     ylab = "PVE acumulada", 
     xlab = "Componente principal", 
     col = "brown3")
```


```{r}
## Loadings
# Component loadings express the combination of original variables that define each of the four main components generated. They allow us to find out which variables are most related to each component

head(res.pca$rotation)[, 1:5]
#dim(res.pca$rotation)
```


```{r}
# Results for individuals
res.ind <- get_pca_ind(res.pca)
res.ind$coord[1:5,1:5]          # Coordinates in graph of individuals (below)
res.ind$contrib[1:5,1:5]        # Contributions to the PCs
res.ind$cos2[1:5,1:5]           # Quality of representation 
```


```{r}
# Graph of individuals. Individuals with a similar profile are grouped together

fviz_pca_ind(res.pca,
             repel = TRUE,  # Avoid text overlapping
             #geom.ind = "point", 
             col.ind = "#FC4E07", 
             axes = c(1, 2), # the two first components
             pointsize = 1.5
             )

```


```{r}
palette_ctgroups <- c("darkseagreen1", # Adipocytes
            "firebrick3", # Blood_and_immune
            "mediumpurple3", # Endocrine
            "maroon3", # Endothelial (Vascular)
            "skyblue1", # Germ
            "darkorchid4", # glandular_epithelial
            "orange", # Glial
            "chartreuse3", # Mesenchymal
            "orange", # mixed_cell_types
            "brown", # mixed_immune
            "indianred1", # Muscle
            "gray3", # Neuronal
            "peachpuff", # Pigment
            "steelblue4", # Squamous_epithelial
            "turquoise4", # Specialized_epithelial
            "pink", # Trophoblast
            "mediumturquoise" # Undifferentiated
            ) 

groups <- as.factor(df_pTPM$Cell_type_group) # by cel type is equally interesting but I have problems
palette_PCA <- distinctColorPalette(length(groups))


fviz_pca_ind(res.pca,
             col.ind = groups, # color by groups
             palette = palette_ctgroups,
             legend.title = "Groups",
             repel = TRUE
             )

```


```{r}
# Results for Variables
res.var <- get_pca_var(res.pca)
res.var$coord[1:5,1:5]          # Coordinates in the graph of variables
res.var$contrib[1:5,1:5]        # Contributions to the PCs
res.var$cos2[1:5,1:5]           # Quality of representation 
```


```{r}
# Graph of variables. Positive correlated variables point to the same side of the plot. Negative correlated variables point to opposite sides of the graph
fviz_pca_var(res.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )
```


```{r}
fviz_pca_var(res.pca, col.var = "cos2", 
             geom.var = "arrow", 
             labelsize = 2, 
             repel = TRUE)
```



```{r}
# Total cos2 of variables on PC1 and PC2 
fviz_cos2(res.pca, choice = "var", axes = 1:2)
```





### 1.4.8. Cell subtypes


The fact that two or more clusters belonging to the same tissue have been identified as the same cell type is due to the fact that their cells express cell type markers, but maintain important differences in their gene expression. One might think that this could be due in part to the fact that the cells of the different clusters are at different stages of their cell cycle, and therefore would be expressing different genes. However, the differences in gene expression at different stages of the cell cycle in the same cell type are minimal, so I do not think this is the main cause. 

Another possible explanation is that they contain cells in formation, i.e., cells that are in the later stages of cell differentiation. This could be tried to be corroborated by comparing the gene expression of the cluster with that of another identified as its progenitor/basal cell type. Ideally, the study of the differential expression of genes makes it possible to identify cell markers that mitigate these epigenetic differences between cells and thus allow cell identification regardless of the environmental conditions to which the cells may be subjected. 

In addition, it should be kept in mind that the data we are working with do not contain epigenetic information, i.e., information about external factors that might have affected the individual gene expression of each cell.  Perhaps cells subjected to similar external conditions clustered in one cluster, and cells of the same cell type subjected to external factors in the other. 

The last possibility that comes to mind is that these are indeed true cell subtypes. To check the latter, one would have to look at the gene expression of markers for cell subtypes across all the clusters, those whose expression is much higher than the others might indicate a subtype.


```{r}
## Adipose tissue Pie

# Colours (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)
t_cells <- colorRampPalette(c("gold", "goldenrod4"))
t_cells<- t_cells(6)
fibroblasts<- colorRampPalette(c("deepskyblue", "dodgerblue4"))
fibroblasts<- fibroblasts(6)
macrophages<- colorRampPalette(c("deeppink", "deeppink4"))
macrophages<- macrophages(4)
dendritic_cells<- colorRampPalette(c("darkorchid1", "darkorchid4"))
dendritic_cells<- dendritic_cells(3)
adipocytes<- colorRampPalette(c("darkorange", "darkorange2"))
adipocytes<- adipocytes(2)

outer_pie_pallete<- c(adipocytes, "firebrick1", dendritic_cells, fibroblasts, macrophages, "green1", "pink", t_cells)
inner_pie_pallete<- c("darkorange1", "firebrick2", "darkorchid2", "deepskyblue2", "deeppink2", "green2", "pink2", "gold2")

PieChart(my_tissue="adipose tissue", my_title= "Adipose tissue\n", my_subtitle="\n\nData source: Karlsson et al. (2021)", my_OuterPallete=outer_pie_pallete, my_InnerPallete=inner_pie_pallete)
```


```{r}
## Breast Pie

# Colours (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)
adipocytes<- colorRampPalette(c("darkorange", "darkorange3"))
adipocytes<- adipocytes(3)
breast_glandular_cells<- colorRampPalette(c("deepskyblue", "dodgerblue4"))
breast_glandular_cells<- breast_glandular_cells(7)
endothelial_cells<- colorRampPalette(c("darkseagreen1", "darkseagreen3"))
endothelial_cells<- endothelial_cells(3)
fibroblasts<- colorRampPalette(c("aquamarine", "aquamarine3"))
fibroblasts<- fibroblasts(3)
macrophages<- colorRampPalette(c("deeppink", "deeppink3"))
macrophages<- macrophages(2)
t_cells <- colorRampPalette(c("gold", "goldenrod4"))
t_cells<- t_cells(4)

outer_pie_pallete<- c(adipocytes, "firebrick1", breast_glandular_cells, "green1", "pink", endothelial_cells, fibroblasts, macrophages, "red", t_cells)
inner_pie_pallete<- c("darkorange1", "firebrick2", "deepskyblue2", "green2", "pink2", "darkseagreen2", "aquamarine2", "deeppink2", "red2", "gold2")


PieChart(my_tissue="breast", my_title= "Breast\n", my_subtitle="\n\nData source: Karlsson et al. (2021)", my_OuterPallete=outer_pie_pallete, my_InnerPallete=inner_pie_pallete)
```


```{r}
# Prostate Pie

# Colours (http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)
basal_prostatic_cells <- colorRampPalette(c("gold", "gold4"))
basal_prostatic_cells<- basal_prostatic_cells(5)
prostatic_glandular_cells<- colorRampPalette(c("deepskyblue", "deepskyblue4"))
prostatic_glandular_cells<- prostatic_glandular_cells(4)
urothelial_cells<- colorRampPalette(c("darkorchid1", "darkorchid4"))
urothelial_cells<- urothelial_cells(3)

outer_pie_pallete<- c(basal_prostatic_cells, "firebrick1", "chocolate1", "chartreuse3", prostatic_glandular_cells, "aquamarine", "pink2", urothelial_cells)

inner_pie_pallete<- c("gold2", "firebrick2", "chocolate2", "chartreuse2", "deepskyblue2", "aquamarine2", "pink", "darkorchid2")

PieChart(my_tissue="prostate", my_title= "Prostate\n", my_subtitle="\n\nData source: Karlsson et al. (2021)", my_OuterPallete=outer_pie_pallete, my_InnerPallete=inner_pie_pallete)
```



```{r}
# escala logaritmica: https://www.datanovia.com/en/blog/ggplot-log-scale-transformation/

# Example: my_data=df_markers, my_y= df_markers$FABP4, my_title="FABP4", my_legend_title="Adipocytes from"

marker_expression_function<- function(my_data, my_y, my_title, my_legend_title) {
  
  ggplot(data=my_data, aes(x=ID, y=my_y, fill=Classification)) +
  geom_bar(stat="identity", position=position_dodge(), width = 0.7) +
  theme_minimal() +
  theme(axis.text.x=element_text(colour="grey20",size=5, angle = 90, vjust = 0.5, hjust=1),
        axis.text.y=element_text(colour="grey20", size=10,vjust=0.5, hjust=1),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Clusters", y = "Gene expression (pTPM)") + 
  theme(axis.text=element_text(size=15), 
        axis.title=element_text(size=20)) + 
  labs(title = my_title,
       caption = "\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=25, face = "bold"),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(legend.position=c(0.8, 0.7),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA)),
        axis.text.x=element_blank()) +
  guides(fill=guide_legend(title=my_legend_title))
}
```



Esta fucnión devuleve 6 variables para cada célula.

> df_nombre de célula - Es el dataframe filtardo por el tipo de célula. (Por ejemplo con "muscle" sería: df_muscle)

> dfa_nombre de célula - Es el dataframe filtardo por el tipo de célula pero solo con tres columnas, tissueType, cellName y cellMarker. (Por ejemplo con "muscle" sería: dfa_muscle)

> dfb_nombre de célula - Es un dataframe con la primera coulumna como tejido y el resto cada uno de los cellMarker.(Por ejemplo con "muscle" sería: dfb_muscle)

> nombre de célula - Es un vector con el tissueType y los cellMarker que tiene ese tejido. (Por ejemplo con "muscle" sería: muscle)

> c_inclu_nombre de célula - Es un vector con los cellName que se seleccionan con cada célula. (Por ejemplo con "muscle" sería: c_inclu_muscle)

> unique_nombre de célula - Es un vector con los marcadores unicos por tejido de cada célula. (Por ejemplo con "muscle" sería: unique_muscle)


```{r}

## Función para automatizar el proceso

tissue_fun<- function(X){
  
X_1<- str_remove(X,"\\^")
X_2<- str_remove(X_1,"\\$")
  
# creación de listas con el nombre de los dataframe dfb_ , nombre de las variables unique_ y lista de células usadas

if (exists("list_cell") == FALSE){
    
    list_cell<<-c()
}
list_cell<<-c(list_cell, str_replace(X_2, " ", "_")) # Vecton con todos los nombres de las células que se usan en esta fúnción


if (exists("list_uni") == FALSE){
    
    list_uni<<-c()
}
list_uni<<-c(list_uni, paste("unique",str_replace(X_2, " ", "_"), sep="_")) # Vecton con todos los nombres de las variables unique_....


if (exists("list_dfb") == FALSE){
    
    list_dfb<<-c()
}

list_dfb<<-c(list_dfb, paste("dfb",str_replace(X_2, " ", "_"), sep="_")) # Vecton con todos los nombres de las variables dfb_.....


# ------------------------------------------

# Filtado del dataset

main_tissue<- CellMarker_df %>% filter_at( vars(cellName), any_vars(str_detect(., regex(X, ignore_case = TRUE)))) # Filtrado del dataset original por un tipo de célula

tissue<- main_tissue %>% select(tissueType, cellName, cellMarker) %>% arrange(tissueType)

sample_tissue<- tissue %>% pull(tissueType) # Separa los tejidos

sample_marker<- tissue %>% pull(cellMarker) # Separa los marcadores

sample_join<<- c()

for (i in seq_along(sample_tissue)){
  
  sample_join<<- c( sample_join, paste(sample_tissue[i], sample_marker[i], sep= ", ")) # Une cada tejido con sus marcadores
}

# 

array<- str_split(sample_join, ", ", simplify = TRUE) # Separa en cadenas individuales el tejido y los marcadores
array<- as.data.frame(array)
array<- rename(array, Tissue=V1) # Dataframe con cada tejidos y sus marcadores en bruto

A<<- tissue %>% pull(cellName)
B<<- unique(A)                 # Nombres únicos de los tejidos
M<<- main_tissue               # Dataset filtrado por células
Ti<<- tissue                   # Dataset filtrado por células con solo tres columnas, Tissue, cellName y cellMarker

# Creación de las variables por célula con cada tejidos y sus marcadores

A_names<- array %>% distinct(Tissue) %>% pull()

uni<- list()

for (i in A_names){
 AA<- array %>% filter(Tissue == i)
 AA<- unlist(AA)
 AA<- unique(AA)
 uni<- c(uni,AA) # Vector refinado con cada tejidos y sus marcadores en bruto, no es definitivo
 }

uni<- na_if(uni, "") # Cambia cadenas vacías por missing values (NA)
uni<- coalesce(uni, as.list("NA")) #Cambia misisng values por cadenas "NA"

# Eliminar todos los cellMarker repetidos en varios tejidos

rep<- c()

for (i in uni){
  if (length(str_which(uni, i)) > 1){
    
    rep<- c(rep,i) # Vector con marcadores repetidos (incluye tejidos)
  }
}

B_names<-paste0("^",A_names, "$")

for (i in B_names){
  
  rep<- str_remove_all(rep,i) # Elimina los tejidos del vertor rep
}

rep<- paste0("^",rep,"$")

for (i in rep){
  
  uni<- str_remove_all(uni,i) # Elimina marcadores repetidos en varios tejidos. Vector definitivo tejido y marcadores
}
uni<- na_if(uni, "") # <-- Convierte las cadenas vacías en valores NA
uni<-na.omit(uni) # <---- Elimina valores NA en el vector final
uni<- as.list(uni) # <---- Convierte de vector a lista 

# Cambio de nombre de variables para sacarlas de la función



assign(str_replace(X_2, " ", "_"), sample_join, envir= .GlobalEnv)
assign(paste("c_inclu",str_replace(X_2, " ", "_"), sep="_"), B, envir= .GlobalEnv)

assign(paste("df",str_replace(X_2, " ", "_"), sep="_"), M, envir= .GlobalEnv)
assign(paste("dfa",str_replace(X_2, " ", "_"), sep="_"), Ti, envir= .GlobalEnv)
assign(paste("dfb",str_replace(X_2, " ", "_"), sep="_"), array, envir= .GlobalEnv)

assign(paste("unique",str_replace(X_2, " ", "_"), sep="_"), uni, envir= .GlobalEnv)

}
```

Llamar a la fucnión:

> names 

Contiene los nombres de las células que queremos filtrar, si queremos añadir alguna más pondríamos dentro de este vector el nombre.

> El bucle

Con el bucle llamamos a la función que hemos creado de forma automática para que se ejecute con cada célula del vector "names".


  
```{r}
# "undifferentiated cells", "mixed cell types" no los he incluido
# "ciliated"
# clara cells = club cells
# en "enterocyte", las del small intestine se refieren a progenitor
# no existe chromophobic (C) cell en la abse de datos
# no encuentro las subdivisiones de astrocitos hechas por Vickarious
# no hay para skeletal myocytes
# no hay para horizontal cells
# no hay para cone y rod photoreceptor cells
# No hay subtipos para bipolar cells

# Pit cells are liver-specific natural killer (NK) cells and belong to the group of sinusoidal cells, together with Kupffer, endothelial, and fat-storing cells (https://pubmed.ncbi.nlm.nih.gov/9408963/)

names<-c("helper", "Natural killer T", "cytotoxic", "Suppressor T cell", "regulatory T", "T cell", "macrophage", "endothelial", "^Fibroblast$", "smooth", "B cell", "Plasma cell", "dendritic", "Goblet cell", "paneth", "adipocyte", "Red blood cell", "^Erythroid cell$", "ciliated", "clara", "enterocyte", "Enteroendocrine", "^Granulocyte$", "monocyte", "alpha", "beta", "delta", "^Oligodendrocyte$", "astrocyte")
```


```{r}
# Bucle para conseguir las variables

for (i in names){
  tissue_fun(i)
  
}
```


Función para obtener datframe de cada célula con sus tejidos y marcadores. Ya eliminados los marcadores que se repiten en varios tejidos. Usa datos que se generan en la función tissue_fun, por lo que hay que ejecutarla antes que esta.

La función devuelve un dataframe por célula.

> df_marker_nombre de célula - Es el dataframe que devuelve con los tejidos y marcadores. (Por ejemplo con "muscle" sería: df_marker_muscle)



```{r}
### --- EXECUTE ONCE ---, en caso de querer hacerlo, ejecutar primero tissue_fun()

sel_marker<-function(X,Y,Z) {
  
for (j in seq_along(X)){

pre_marker<- get(X[j]) %>% distinct(Tissue) %>% pull()   # Carga el dataframe de cada célula
pre_marker<- str_squish(pre_marker)
pre_marker_s<- paste0("^",pre_marker,"$")

u_marker<- data.frame(Tissue=rep(NA, times= length(pre_marker)), cellMarker=rep(NA, times= length(pre_marker)))   # Dataframe vacío de las medidas de cada célula
for (i in seq_along(pre_marker)){
  
    u_marker[i,1]<- get(Y[j])[str_which(get(Y[j]), pre_marker_s[i])]   # Rellena la primera columna del dataframe con los tejidos
    
    if (length(str_which(get(Y[j]), pre_marker[i+1])) == 0){   # Condicional para evaluar la posición que ocupa el tejido
  
  stars<- str_which(get(Y[j]), pre_marker_s[i]) +1   # Fija valores del rango a coger del vector
  finish<- length(get(Y[j]))
  
  if (get(Y[j])[stars] %in% pre_marker){
           
            u_marker[i,2]<- "NA"
            
           } else {
  
            merge<- get(Y[j])[stars:finish]   # Selecciona los marcadores dentro de ese rango
  
           u_marker[i,2]<- str_flatten(merge, collapse=", ")   # Añade los marcadores a su celda correspondiente
          }
  
        } else {
  
             stars<- str_which(get(Y[j]), pre_marker_s[i]) +1    # Fija valores del rango a coger del vector
             finish<- str_which(get(Y[j]), pre_marker_s[i+1]) -1
  
         if (get(Y[j])[stars] %in% pre_marker){
           
             u_marker[i,2]<- "NA"
           
         } else {
           
          merge<-get(Y[j])[stars:finish]   # Selecciona los marcadores dentro de ese rango
  
           u_marker[i,2]<- str_flatten(merge, collapse=", ")   # Añade los marcadores a su celda correspondiente
         }
   
   }
  }

  # Cambio de nombre de variables para sacarlas de la función
  assign(paste("df_marker",str_replace(Z[j], " ", "_"), sep="_"), u_marker, envir= .GlobalEnv)
 }
}


```

Llamamos a la función que tiene 3 argumentos.

> El primero es el vector list_dfa que contiene el nombre de todos los dataframe dfa_.... generados en la función Tissue_fun()

> El segundo argumento es el vector list_uni que contiene el nombre de todos los vectore unique_.... generados en la función Tissue_fun()

> El tercer argumento es el vector list_cell que contiene el nombre de todas las células usadas en la función Tissue_fun()

Esta función, sel_marker() cada vez que se use hay que borrar previamente el enviroment de R, ya que en su código genera y borrar elementos que si se ejecuta una segunda vez darían errores, no fallaría pero los resultados no serían correctos.



```{r}
## Llamamos a la función

sel_marker(list_dfb,list_uni,list_cell)
```


```{r}
# TEXTO (MARKERS)

fun_1<- function(X) {
  var<- paste0("df_marker_",X)
  var<- str_replace_all(var," ","_") 
  cell_nm<-X
  cell_nm<- str_replace_all(cell_nm," ","_")

for (i in seq_along(var)){
  ts<- get(var[i])$Tissue
  cat(red$bold("\n",cell_nm[i]))

for (j in seq_along(ts)){
  
   cat(green$bold("\n",ts[j]))

 print(get(var[i]) %>% slice(j) %>% pull(cellMarker) %>% str_split(", ") %>% unlist())
 

  }
 }
}

#fun_1(list_cell)


```




```{r}
# LISTA CON LOS MARKERS

fun_2<- function(X) {
  var<- paste0("df_marker_",X)
  var<- str_replace_all(var," ","_") 
  cell_nm<-X
  cell_nm<- str_replace_all(cell_nm," ","_")

for (i in seq_along(cell_nm)){
  ts<- get(var[i])$Tissue
  
 a<- get(var[i]) %>% slice(1:length(ts)) %>% pull(cellMarker) %>% str_split(", ") %>% unlist()
 assign(paste(cell_nm[i], "Marker", sep="_"), a, envir= .GlobalEnv)

 }
}

fun_2(list_cell)
```





#### 1.4.8.1. t-cells



- lymphocyte, helper T (CD4)
- lymphocyte, killer T (also known as cytotoxic T cell)(CD8) 
- lymphocyte, suppressor T (also known as regulatory T cells) (CD4)



```{r}
# Visualize clusters belonging to a specific cell type
UMAPcelltype("t-cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "t-cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "bone marrow") {
    df_markers[i,1] <- "bone marrow"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "endometrium") {
    df_markers[i,1] <- "endometrium"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "esophagus") {
    df_markers[i,1] <- "esophagus"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "kidney") {
    df_markers[i,1] <- "kidney"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "liver") {
    df_markers[i,1] <- "liver"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "lung") {
    df_markers[i,1] <- "lung"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "lymph node") {
    df_markers[i,1] <- "lymph node"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "ovary") {
    df_markers[i,1] <- "ovary"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "pbmc") {
    df_markers[i,1] <- "pbmc"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "prostate") {
    df_markers[i,1] <- "prostate"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "skeletal muscle") {
    df_markers[i,1] <- "skeletal muscle"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "skin") {
    df_markers[i,1] <- "skin"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "spleen") {
    df_markers[i,1] <- "spleen"
  } 
  
  else if (df_markers[i,3] == "t-cells" & df_markers[i,4] == "stomach") {
    df_markers[i,1] <- "stomach"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
# lymphocyte, helper T (CD4)
# STAT1, BATF

helper_Marker_random<- sample(helper_Marker, 10)

for (i in helper_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



```{r}
# lymphocyte, killer T (also known as cytotoxic T cell)(CD8) 

Natural_killer_T_Marker_random<- sample(Natural_killer_T_Marker, 10)

for (i in Natural_killer_T_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="Adipocytes from"))
    
  }
  
  else {
    
  }
}
```



```{r}
# lymphocyte, killer T (also known as cytotoxic T cell)(CD8) 

cytotoxic_Marker_random<- sample(cytotoxic_Marker, 10)

for (i in cytotoxic_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="Adipocytes from"))
    
  }
  
  else {
    
  }
}
```


```{r}
# lymphocyte, suppressor T (also known as regulatory T cells) (CD4) 

for (i in Suppressor_T_cell_Marker) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="Adipocytes from"))
    
  }
  
  else {
    
  }
}
```


```{r}
# lymphocyte, suppressor T (also known as regulatory T cells) (CD4) 

regulatory_T_Marker_random<- sample(regulatory_T_Marker, 10)

for (i in regulatory_T_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="Adipocytes from"))
    
  }
  
  else {
    
  }
}
```


```{r}
# T cell (in general)

T_cell_Marker_random<- sample(T_cell_Marker, 10)

for (i in T_cell_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="Adipocytes from"))
    
  }
  
  else {
    
  }
}
```


Usando el mismo criterio que Karlsson et all. (2021), he clasificado los genes en diferentes categorias. OJO, porque he hecho esto en un data frame filtrado por el tipo celular "t-cell":


**Category**: Cell type enriched
**Classification rule**: A single cell type has 4 times higher expression than any other cell type

**Category**: Group enriched
**Classification rule**: 2-10 cell types have 4 times higher expression than any other cell type

**Category**: Cell type enhanced
**Classification rule**: One or more cell types have 4 times higher expression than the average of all other cell types

**Category**: Low cell type specificity
**Classification rule**: The gene does not belong to any of the above categories and is detected above cut off (NX=1) in at least one cell type


```{r}
df<- read_csv("df_CellType.csv")
```


```{r}
df_A<- df[1,1]
df_A[1,1]<- "NULL"
graf<-rbind(c(rep(NA, 46)))
df_A<- cbind(df_A, graf)
colnames(df_A)<- c(colnames(df))



cumulative<- c()



for (j in seq_along(df$`t-cells adipose tissue c-1`)){
base<- df[j,1]
graf<-rbind(c(rep(NA, 46)))
base<- cbind(base, graf)
colnames(base)<- c(colnames(df))

cal<- unlist(df[j,2:length(df)])

cumulative<- c()

# Valoramos cuántas cell hay que *4 sean mayor que el valor max

for (q in seq_along(cal)){
  
  if (cal[q]*4 > max(cal)){
    
    cumulative<-c(cumulative,"item")
  }
  
}


for (i in seq_along(cal)){
  
  if (length(cumulative) <=1){
    
    if (cal[i]*4 > max(cal)){
      
      base[1,i+1]<- "Cell type enriched"
    }
    else if (cal[i]*4 > mean(cal)){
      
       base[1,i+1]<- "Cell type enhanced"
    } else {
      base[1,i+1]<- "unclassified"
      }
    
  } 
  
  if (length(cumulative) >1 & length(cumulative) <=10){
      
    if (cal[i]*4 > max(cal)){
      
      base[1,i+1]<- "Group enriched"
    }
    else if (cal[i]*4 > mean(cal)){
      
       base[1,i+1]<- "Cell type enhanced"
    } else {
      base[1,i+1]<- "unclassified"
      }
  } 
  
  if (length(cumulative) >10){
      
    if (cal[i]*4 > max(cal)){
      
      base[1,i+1]<- "Cell type enhanced"
    }
    else if (cal[i]*4 > mean(cal)){
      
       base[1,i+1]<- "Cell type enhanced"
    } else {
      base[1,i+1]<- "unclassified"
      }
  }
  
  
}

df_A<- rbind(df_A,base)

}


```



Creo que el PCA aplicado para reducir los tipos celulares como variables a una o dos componentes es útil para ver qué genes varían su expresión más (se expresan mucho más o mucho menos) en todos los clusteres. Creo que el PCA actua de la siguiente manera: De cada gen (fila) hace un cálculo de la vraianza en la expresión de ese gen a lo largo de todas las variables (clusteres). Y así con todos los genes. Después, selecciona los genes con más varianza y son los que aportan más información en las primeras componentes.

Creo que aplicar PCA estando los genes como variables (colummas) con el mismo objetivo no tiene sentido porque nos interesa comparar la expresión de un gen en todos los tipos cleulares en comparación con la expresión de los demás gen en todos los tipos celulares. Colocando los genes en las columnas, lo que obtendrías es los genes que varían más en solo un tipo celular en las primeras componentes, pero queremos los genes que varían más en todos los clusteres.

Identification of biomarkers from transcriptomic data:


```{r}
# rows = genes, columns = clusters
df_CellType<- df_pTPM_genes %>% select(starts_with("t-cells"))
#write.csv(df_CellType, "df_CellType.csv")
```


```{r}
# Distribution of gene expression values in t-cells identified clusters
boxplot(df_CellType, main = "Number of atypical genes per cluster",
        xlab = "\n\nCell type", ylab = "Gene expression (pTPM)", cex.axis = 0.75, las = 2)
```


```{r}
### Using the princomp function to calculate PCA
# PCA is affected by scale, so you need to scale the features in your data before applying PCA (mean = 0 and standard deviation = 1)
PCA_CellType<-princomp(df_CellType,cor=FALSE,scores=TRUE)
# setting cor=FALSE to use covariance, not correlation
```


```{r}
# Plotting variance explained by each component
plot(PCA_CellType, main = "Explained variance per Principal Component")

# Another way to visualize it
plot(PCA_CellType, type = "l", main = "Explained variance per Principal Component")

# Percentage of variance captured by each component
fviz_eig(PCA_CellType, ncp=10, addlabels = TRUE, ylim = c(0, 100))


# PVE: Proporción de varianza explicada
PVE <- 100*PCA_CellType$sdev^2/sum(PCA_CellType$sdev^2)

par(mfrow = c(1,2))

plot(PVE, type = "o", 
     ylab = "PVE", 
     xlab = "Componente principal", 
     col = "blue")
plot(cumsum(PVE), type = "o", 
     ylab = "PVE acumulada", 
     xlab = "Componente principal", 
     col = "brown3")
```


```{r}
# see first five loadings from the first two PC's
PCA_CellType$loadings[1:5, 1:2]
```

```{r}
# Access names of the loadings
row.names(PCA_CellType$loadings[, 1:2])
```


```{r}
# To improve the understanding of the visualization, I am renaming the labels
pca_labels <- c("adipo c-1", "adipo c-2", "adipo c-3", "adipo c-9",
                "adipo c-10",  "adipo c-15", "BM c-0", "BM c-1",
                "BM c-2", "BM c-4", "BM c-5", "BM c-7",
                "breast c-1", "breast c-4", "breast c-8", "breast c-13",
                "colon c-3", "endom c-4", "endom c-26", "esoph c-13",
                "kidney c-7", "liver c-1", "liver c-8", "liver c-10",
                "liver c-15", "lung c-3", "lymph c-1", "lymph c-3",
                "ovary c-17", "pbmc c-1", "pbmc c-2", "pbmc c-3",
                "pbmc c-4", "pbmc c-6", "prostate c-16", "skeletal c-8",
                "skin c-7", "spleen c-1", "spleen c-2", "spleen c-4",
                "spleen c-6", "spleen c-7", "stomach c-1", "stomach c-2",
                "stomach c-3", "stomach c-4"
                )
```


```{r}
# Plotting the loadings for the first two components (the most significant)
plot(PCA_CellType$loadings[, 1:2], main = "Variability of each sample across PC 1 and 2")
text(PCA_CellType$loadings[, 1:2],
     labels=pca_labels,
     pos=c(1, 1, 4, 1, 
           4, 3, 3, 1,
           2, 1, 1, 1,
           2, 2, 1, 1,
           4, 1, 3, 1,
           4, 4, 4, 4,
           4, 2, 4, 1,
           1, 2, 4, 1,
           4, 4, 2, 4,
           4, 3, 1, 4,
           2, 1, 3, 3,
           4, 3)) # 1=down to the point; 2=left to the point; 3=up to the point; 4=right to the point
```


I am going to extract the top and bottom 100 scores for the first principal component (the first component explains most of the variability):


```{r}
# Sorting scores by the PC1 (column 1)
sorted_scores1 <- sort(PCA_CellType$scores[,1])

# The lowest scores (more negative) are obtained with head
lowest_scores1 <- head(sorted_scores1, 100)

# The highest scores (more positive) are obtained with tail
highest_scores1 <- tail(sorted_scores1, 100)
```


```{r}
# Selecting the data corresponding to those genes (with their names)
# converting it to matrix to use it in heatmap
low_data1 <- as.matrix(df_CellType[names(lowest_scores1), ])
high_data1 <- as.matrix(df_CellType[names(highest_scores1), ])

# changing them so that they are the same as in the PCA loadings
colnames(low_data1) <- pca_labels
colnames(high_data1) <- pca_labels
```


```{r}
# Lowest scores
heatmap(low_data1, main = "Heatmap, lowest scoring genes, PC 1",
        col = colorRampPalette(colors = c("blue", "black", "yellow"))(256),
        margins = c(7, 2))

# Highest scores
heatmap(high_data1, main = "Heatmap, highest scoring genes, PC 1",
        col = colorRampPalette(colors = c("blue", "black", "yellow"))(256),
        margins = c(7, 2))
```


Now, I will extract the top and bottom 100 scores for the first and second principal components:


```{r}
# Sorting scores by the PC2 (column 2)
sorted_scores2 <- sort(PCA_CellType$scores[,2])

# The lowest scores (more negative) are obtained with head
lowest_scores2 <- head(sorted_scores2, 100)

# The highest scores (more positive) are obtained with tail
highest_scores2 <- tail(sorted_scores2, 100)
```


```{r}
# Merging both names (from PC 1 and PC 2) and deleting duplicates
lowest_scoring_genes_1_2 <- unique(c(names(lowest_scores1), names(lowest_scores2)))
highest_scoring_genes_1_2 <- unique(c(names(highest_scores1), names(highest_scores2)))
```


```{r}
# Selecting the data corresponding to those genes (with their names)
# converting it to matrix to use it in heatmap
low_data12 <- as.matrix(df_CellType[lowest_scoring_genes_1_2, ])
high_data12 <- as.matrix(df_CellType[highest_scoring_genes_1_2, ])

# changing them so that they are the same as in the PCA loadings
colnames(low_data12) <- pca_labels
colnames(high_data12) <- pca_labels
```



```{r}
# Lowest scores
heatmap(low_data12, main = "Heatmap, lowest scoring genes, PC 1 and 2",
        col = colorRampPalette(colors = c("blue", "black", "yellow"))(256),
        margins = c(7, 2))

# Highest scores
heatmap(high_data12, main = "Heatmap, highest scoring genes, PC 1 and 2",
        col = colorRampPalette(colors = c("blue", "black", "yellow"))(256),
        margins = c(7, 2))
```


Now, I want to plot the clusters after reducing the ~20,000 genes to two PC's.


```{r}
# rows = clusters, columns = genes
df_tcells_2<- as.data.frame(t(df_CellType))
```


```{r}
# Remove invariant genes
df_tcells_2<- df_tcells_2[, colSums(df_tcells_2 != 0) > 0]
```


```{r}
# Compute PCA
# PCA is affected by scale, so you need to scale the features in your data before applying PCA (mean = 0 and standard deviation = 1)
PCA_CellType_2 <- prcomp(df_tcells_2, scale = TRUE)
# prcomp() not scale by default
```


```{r}
# Scores vectors
head(PCA_CellType_2$x)[,1:5]

# Eigenvalues measure the amount of variation retained by each principal component.
# The sum of all the eigenvalues give a total variance of 1
# Plotting variance explained by each component
plot(PCA_CellType_2, main = "Explained variance per Principal Component")

# Another way to plot variance
plot(PCA_CellType_2, type = "l", main = "Explained variance per Principal Component")

# Plotting the percentage of variance captured by each component
fviz_eig(PCA_CellType_2, ncp=12, addlabels = TRUE, ylim = c(0, 100))

# PVE: Proporción de varianza explicada
PVE <- 100*PCA_CellType_2$sdev^2/sum(PCA_CellType_2$sdev^2)

par(mfrow = c(1,2))

plot(PVE, type = "o", 
     ylab = "PVE", 
     xlab = "Componente principal", 
     col = "blue")
plot(cumsum(PVE), type = "o", 
     ylab = "PVE acumulada", 
     xlab = "Componente principal", 
     col = "brown3")


# Eigenvalues, with information about variance percentage and cumulative variance percentage per principal component
eig.val <- get_eigenvalue(PCA_CellType_2)
eig.val
```


```{r}
# Top 100 variables that contrinute the most to PC1
fviz_contrib(PCA_CellType_2, choice = "var", axes = 1, top = 100)

# Top 100 variables that contrinute the most to PC2
fviz_contrib(PCA_CellType_2, choice = "var", axes = 2, top = 100)

# Top 100 variables that contrinute the most to PCA1 and PC2
fviz_contrib(PCA_CellType_2, choice = "var", axes = 1:2, top = 100)


# The dashed red line indicates the average contribution value. For a given component, a variable with a contribution greater than this limit can be considered important in contributing to this component.
```


```{r}
# As expected, explained variance is greater in the first component comparing to the following ones
#summary(res.pca)
```


```{r}
## Loadings
# Component loadings express the combination of original variables that define each of the four main components generated. They allow us to find out which variables are most related to each component

head(PCA_CellType_2$rotation)[, 1:5]
#dim(res.pca$rotation)
```


Cabe destacar que la representación gráfica de las observaciones y las variables es distinta: las observaciones se representan mediante sus proyecciones, mientras que las variables se representan mediante sus correlaciones. La correlación entre una componente y una variable estima la información que comparten -> loadings, por lo que las variables se pueden representar como puntos en el espacio de los componentes utilizando sus loadings como coordenadas.


```{r}
# Results for individuals
res.ind <- get_pca_ind(PCA_CellType_2)
res.ind$coord[1:5,1:5]          # Coordinates in graph of individuals (below)
res.ind$contrib[1:5,1:5]        # Contributions to the PCs
res.ind$cos2[1:5,1:5]           # Quality of representation 
```


```{r}
# Graph of individuals. Individuals with a similar profile are grouped together

fviz_pca_ind(PCA_CellType_2,
             repel = TRUE,  # Avoid text overlapping
             #geom.ind = "point", 
             col.ind = "#FC4E07", 
             axes = c(1, 2), # the two first components
             pointsize = 1.5
             )

```


```{r}
#n_tcells_samples = 38; n_rest = 120 
#cell_type = c(rep("oligodendrocyte", n_oligo_samples), rep("neuron", n_neuron_samples))
```





#### 1.4.8.2. macrophages


"macrophages":
- macrophage, alveolar
- macrophage, connective tissue
- macrophage, multinucleated
- macrophage, serous cavity
- macrophage, splenic


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("macrophages")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "macrophages")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "bone marrow") {
    df_markers[i,1] <- "bone marrow"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "endometrium") {
    df_markers[i,1] <- "endometrium"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "esophagus") {
    df_markers[i,1] <- "esophagus"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "kidney") {
    df_markers[i,1] <- "kidney"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "lung") {
    df_markers[i,1] <- "lung"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "ovary") {
    df_markers[i,1] <- "ovary"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "pancreas") {
    df_markers[i,1] <- "pancreas"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "pbmc") {
    df_markers[i,1] <- "pbmc"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "prostate") {
    df_markers[i,1] <- "prostate"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "skeletal muscle") {
    df_markers[i,1] <- "skeletal muscle"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "spleen") {
    df_markers[i,1] <- "spleen"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "stomach") {
    df_markers[i,1] <- "stomach"
  } 
  
  else if (df_markers[i,3] == "macrophages" & df_markers[i,4] == "testis") {
    df_markers[i,1] <- "testis"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
macrophage_Marker_random<- sample(macrophage_Marker, 10)

for (i in macrophage_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```

#### 1.4.8.3. endothelial cells 



"endothelial cells":
- endothelial cell, central nervous system
- endothelial cell, continuous
- endothelial cell, corneal
- endothelial cell, fenestrated
- endothelial cell, lymphatic
- endothelial cell, splenic


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("endothelial cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "endothelial cells")
```

```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  
  if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "endometrium") {
    df_markers[i,1] <- "endometrium"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "esophagus") {
    df_markers[i,1] <- "esophagus"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "eye") {
    df_markers[i,1] <- "eye"
  } 
  
   else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "heart muscle") {
    df_markers[i,1] <- "heart muscle"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "liver") {
    df_markers[i,1] <- "liver"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "lung") {
    df_markers[i,1] <- "lung"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "lymph node") {
    df_markers[i,1] <- "lymph node"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "ovary") {
    df_markers[i,1] <- "ovary"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "pancreas") {
    df_markers[i,1] <- "pancreas"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "prostate") {
    df_markers[i,1] <- "prostate"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "skeletal muscle") {
    df_markers[i,1] <- "skeletal muscle"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "skin") {
    df_markers[i,1] <- "skin"
  } 
  
  else if (df_markers[i,3] == "endothelial cells" & df_markers[i,4] == "testis") {
    df_markers[i,1] <- "testis"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
endothelial_Marker_random<- sample(endothelial_Marker, 10)

for (i in endothelial_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



#### 1.4.8.4. fibroblasts

https://www.ontobee.org/ontology/CL?iri=http://purl.obolibrary.org/obo/CL_4028004

```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("fibroblasts")
```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "fibroblasts")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "esophagus") {
    df_markers[i,1] <- "esophagus"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "heart muscle") {
    df_markers[i,1] <- "heart muscle"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "lung") {
    df_markers[i,1] <- "lung"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "ovary") {
    df_markers[i,1] <- "ovary"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "placenta") {
    df_markers[i,1] <- "placenta"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "prostate") {
    df_markers[i,1] <- "prostate"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "skeletal muscle") {
    df_markers[i,1] <- "skeletal muscle"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "skin") {
    df_markers[i,1] <- "skin"
  } 
  
  else if (df_markers[i,3] == "fibroblasts" & df_markers[i,4] == "stomach") {
    df_markers[i,1] <- "stomach"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
Fibroblast_Marker_random<- sample(Fibroblast_Marker, 10)

for (i in Fibroblast_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.5. smooth muscle cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("smooth muscle cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "smooth muscle cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "bronchus") {
    df_markers[i,1] <- "bronchus"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "endometrium") {
    df_markers[i,1] <- "endometrium"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "esophagus") {
    df_markers[i,1] <- "esophagus"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "heart muscle") {
    df_markers[i,1] <- "heart muscle"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "ovary") {
    df_markers[i,1] <- "ovary"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "pancreas") {
    df_markers[i,1] <- "pancreas"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "prostate") {
    df_markers[i,1] <- "prostate"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "skeletal muscle") {
    df_markers[i,1] <- "skeletal muscle"
  } 
  
  else if (df_markers[i,3] == "smooth muscle cells" & df_markers[i,4] == "skin") {
    df_markers[i,1] <- "skin"
  } 

  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
smooth_Marker_random<- sample(smooth_Marker, 10)

for (i in smooth_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.6. b-cells


"b-cells":
- lymphocyte, IgA B
- lymphocyte, IgE B
- lymphocyte, IgG B
- lymphocyte, IgM B


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("b-cells")
```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "b-cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "bone marrow") {
    df_markers[i,1] <- "bone marrow"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "kidney") {
    df_markers[i,1] <- "kidney"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "liver") {
    df_markers[i,1] <- "liver"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "lymph node") {
    df_markers[i,1] <- "lymph node"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "pbmc") {
    df_markers[i,1] <- "pbmc"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "spleen") {
    df_markers[i,1] <- "spleen"
  } 
  
  else if (df_markers[i,3] == "b-cells" & df_markers[i,4] == "stomach") {
    df_markers[i,1] <- "stomach"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
B_cell_Marker_random<- sample(B_cell_Marker, 10)

for (i in B_cell_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



#### 1.4.8.7. plasma cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("plasma cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "plasma cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "plasma cells" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "plasma cells" & df_markers[i,4] == "bone marrow") {
    df_markers[i,1] <- "bone marrow"
  } 
 
  else if (df_markers[i,3] == "plasma cells" & df_markers[i,4] == "esophagus") {
    df_markers[i,1] <- "esophagus"
  } 
  
  else if (df_markers[i,3] == "plasma cells" & df_markers[i,4] == "spleen") {
    df_markers[i,1] <- "spleen"
  } 
  
  else if (df_markers[i,3] == "plasma cells" & df_markers[i,4] == "stomach") {
    df_markers[i,1] <- "stomach"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
Plasma_cell_Marker_random<- sample(Plasma_cell_Marker, 10)

for (i in Plasma_cell_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



#### 1.4.8.8. dendritic cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("dendritic cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "dendritic cells")
```

```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "dendritic cells" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "dendritic cells" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else if (df_markers[i,3] == "dendritic cells" & df_markers[i,4] == "pbmc") {
    df_markers[i,1] <- "pbmc"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```

```{r}
dendritic_Marker_random<- sample(dendritic_Marker, 10)

for (i in dendritic_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.9. intestinal goblet cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("intestinal goblet cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "intestinal goblet cells")
```

```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "intestinal goblet cells" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "intestinal goblet cells" & df_markers[i,4] == "rectum") {
    df_markers[i,1] <- "rectum"
  } 
  
  else if (df_markers[i,3] == "intestinal goblet cells" & df_markers[i,4] == "small intestine") {
    df_markers[i,1] <- "small intestine"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```

```{r}
Goblet_cell_Marker_random<- sample(Goblet_cell_Marker, 10)

for (i in Goblet_cell_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```




#### 1.4.8.11. paneth cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("paneth cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "paneth cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  
  if (df_markers[i,3] == "paneth cells" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "paneth cells" & df_markers[i,4] == "rectum") {
    df_markers[i,1] <- "rectum"
  } 
  
  else if (df_markers[i,3] == "paneth cells" & df_markers[i,4] == "small intestine") {
    df_markers[i,1] <- "small intestine"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```

```{r}
paneth_Marker_random<- sample(paneth_Marker, 10)

for (i in paneth_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.12. adipocytes

Two kinds of adipose tissue is found in the human body: white adipose tissue and brown adipose tissue.

The fat can be found throughout the body and surrounds most organs and tissue.  Fat is mainly located either around the organs (visceral adipose tissue) or beneath the skin (subcutaneous adipose tissue).


- Specialized loose connective tissue
- Functions: fat-storage, insulation (protection of organs) and and secretion of hormones (adipokines, such as leptin, estrogen, cytokine).
- Location: surrounds most organs and tissue.
- Cell types: adipocytes, pre-adipocytes, fibroblasts and inflammatory cells. 
- Associated components include blood vessels, peripheral nerves and connective tissue (fibroblasts).


Examples of genes involved in fat-storage:

- FABP4: involved in lipid transport.
- LIPE: hydrolyze the stored triglycerides to free fatty acids.
- PLIN1 and PLIN4: major roles in lipid droplet formation.


55 plasma proteins are identified in the adipose tissue elevated gene lists. These genes are, therefore, shared between adipocytes and plasma cells (from blood). Examples of plasma proteins with elevated expression in adipose tissue include:

- LEP: major role in the regulation of body weight by decreasing food intake and increasing energy expenditure
- ADIPOQ: involved in modulating several of metabolic processes including glucose regulation and lipid oxidation


The adipose tissue shares expression of a few genes with several other tissue types but has the most shared group enriched gene expression with **breast**. An example of group enriched gene expression shared between adipose tissue and liver is ADH1B, a member of the alcohol dehydrogenase family which plays a major role in ethanol catabolism.


Brown adipocytes are thermogenic, a property induced by uncoupling protein 1 (**UCP1**), which is located in the inner mitochondrial membrane. UCP1 enables brown adipocytes to release energy as heat by uncoupling mitochondrial respiration. However, adipocytes from our dataset cannot be clearly distinguised (white or brown)  using this gene.

Multiple studies have identified **LHX8** and **ZIC1** as strong markers of brown adipocytes (41–44). **MPZL2** and **PREX1** are another genetic markers that have been proposed as a candidate for identifying brown adipocytes.


Sources:

The adipose tissue-specific proteome (https://www.proteinatlas.org/humanproteome/tissue/adipose+tissue)
Adipose tissue dictionary (https://www.proteinatlas.org/learn/dictionary/normal/adipose+tissue)
The adipocyte-specific proteome (https://www.proteinatlas.org/humanproteome/single+cell+type/Adipocytes#adipocytes)
Beige Adipose Tissue Identification and Marker Specificity—Overview (https://www.frontiersin.org/articles/10.3389/fendo.2021.599134/full#h4)
Genetic Markers of Brown Adipose Tissue Identity and In Vitro Brown Adipose Tissue Activity in Humans (https://onlinelibrary.wiley.com/doi/epdf/10.1002/oby.22062)



"adipocytes":
- adipose cell, white
- adipose cell, brown
- adipose cell, lipocyte of liver


c("FABP4", "LIPE", "PLIN1", "PLIN4", "ECSCR", "VWF", "PREX1", "MPZL2", "ZIC1", "LHX8", "UCP1", "ME1", "NANOG", "SOX2", "CD34", "CD44")


```{r}
# Visualize clusters belonging to a specific cell type
UMAPcelltype("adipocytes")
```


```{r}
GeneExpression_Adipocytes<- df_pTPM_original %>%  subset(Cell_type == "adipocytes") %>%
  subset(Gene_name %in% c("FABP4", "LIPE", "PLIN1", "PLIN4", "ECSCR", "VWF", "PREX1", "MPZL2", "ZIC1", "LHX8", "UCP1", "ME1", "NANOG", "SOX2", "CD34", "CD44")) %>% 
  arrange(Gene_name)
```


```{r}
# https://stackoverflow.com/questions/62208141/stacked-bar-plot-with-multiple-or-different-legend-for-each-group
# https://maxcandocia.com/article/2020/Aug/30/log-scale-zero-and-negative-values/
# Eje y en escala logaritmica

ggplot(data=GeneExpression_Adipocytes, aes(Gene_name, pTPM, fill=ID)) +
  geom_bar(stat="identity", position=position_dodge(), width = 0.7) +
  scale_fill_manual(values=c("orange", "blue", "red", "pink", "black")) +
  theme_minimal() +
  theme(axis.text.x=element_text(colour="grey20",size=15),
        axis.text.y=element_text(colour="grey20", hjust=1,vjust=0.8,size=10),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Markers", y = "Gene expression (pTPM)") + 
  theme(axis.text=element_text(size=15), 
        axis.title=element_text(size=20)) + 
  labs(title = "Marker's gene expression",
       subtitle = "Differential expression among markers for white and brown adipocyte\n",
       caption = "\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=25, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=20),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(legend.position=c(0.8, 0.7),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  guides(fill=guide_legend(title="Legend"))
 

```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "adipocytes")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "adipocytes" & df_markers[i,4] == "adipose tissue") {
  df_markers[i,1] <- "adipose tissue"
  } 
  
  else if (df_markers[i,3] == "adipocytes" & df_markers[i,4] == "breast") {
    df_markers[i,1] <- "breast"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```



```{r}
adipocyte_Marker_random<- sample(adipocyte_Marker, 10)

for (i in adipocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```





#### 1.4.8.13. erythroid cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("erythroid cells")
```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "erythroid cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  
  if (df_markers[i,3] == "erythroid cells" & df_markers[i,4] == "bone marrow") {
    df_markers[i,1] <- "bone marrow"
  } 
  
  else if (df_markers[i,3] == "erythroid cells" & df_markers[i,4] == "liver") {
    df_markers[i,1] <- "liver"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
adipocyte_Marker_random<- sample(adipocyte_Marker, 10)

for (i in adipocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



#### 1.4.8.15. club cells


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("club cells")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "club cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "club cells" & df_markers[i,4] == "bronchus") {
  df_markers[i,1] <- "bronchus"
  } 
  
  else if (df_markers[i,3] == "club cells" & df_markers[i,4] == "lung") {
    df_markers[i,1] <- "lung"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
for (i in clara_Marker) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.16. distal enterocytes


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("distal enterocytes")
```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "distal enterocytes")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "distal enterocytes" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "distal enterocytes" & df_markers[i,4] == "rectum") {
    df_markers[i,1] <- "rectum"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
# SLC35A4

enterocyte_Marker_random<- sample(enterocyte_Marker, 10)

for (i in enterocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.17. enteroendocrine cells


"enteroendocrine cells":
- gastroenteropancreatic X cell (many subtypes)


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("enteroendocrine cells")
```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "enteroendocrine cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  

   if (df_markers[i,3] == "enteroendocrine cells" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "enteroendocrine cells" & df_markers[i,4] == "rectum") {
    df_markers[i,1] <- "rectum"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
Enteroendocrine_Marker_random<- sample(Enteroendocrine_Marker, 10)

for (i in Enteroendocrine_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


#### 1.4.8.18. granulocytes


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("granulocytes")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "granulocytes")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  
 if (df_markers[i,3] == "granulocytes" & df_markers[i,4] == "colon") {
    df_markers[i,1] <- "colon"
  } 
  
  else if (df_markers[i,3] == "granulocytes" & df_markers[i,4] == "lung") {
    df_markers[i,1] <- "lung"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
# CCR3

Granulocyte_Marker_random<- sample(Granulocyte_Marker, 10)

for (i in Granulocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



#### 1.4.8.20. monocytes 


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("monocytes")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "monocytes")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  

  if (df_markers[i,3] == "monocytes" & df_markers[i,4] == "pbmc") {
    df_markers[i,1] <- "pbmc"
  } 
  
  else if (df_markers[i,3] == "monocytes" & df_markers[i,4] == "pancreas") {
    df_markers[i,1] <- "pancreas"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
monocyte_Marker_random<- sample(monocyte_Marker, 10)

for (i in monocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```

#### 1.4.8.21. pancreatic endocrine cells 


"pancreatic endocrine cells" = pancreatic endocrine cells found in islets of Langerhans
- alpha cell
- beta cell
- delta cell
- No estoy segura: chromophobic (C) cell


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("monocytes")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "pancreatic endocrine cells")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "pancreatic endocrine cells" & df_markers[i,4] == "pancreas") {
    df_markers[i,1] <- "pancreas"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
# alpha cell

alpha_Marker_random<- sample(alpha_Marker, 10)

for (i in alpha_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```

```{r}
# beta cell

beta_Marker_random<- sample(beta_Marker, 10)

for (i in beta_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


```{r}
# delta cell

delta_Marker_random<- sample(delta_Marker, 10)

for (i in delta_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```


```{r}
alpha_beta_delta<- append(alpha_Marker, beta_Marker)
alpha_beta_delta<- append(alpha_beta_delta, delta_Marker)
alpha_beta_delta_random<- sample(alpha_beta_delta, 10)


GeneExpression_pan_endo_cells<- df_pTPM_original %>%  subset(Cell_type == "pancreatic endocrine cells") %>%
  subset(Gene_name %in% alpha_beta_delta_random) %>% arrange(Gene_name)
```


```{r}
# https://stackoverflow.com/questions/62208141/stacked-bar-plot-with-multiple-or-different-legend-for-each-group
# https://maxcandocia.com/article/2020/Aug/30/log-scale-zero-and-negative-values/
# Eje y en escala logaritmica

ggplot(data=GeneExpression_pan_endo_cells, aes(Gene_name, pTPM, fill=ID)) +
  geom_bar(stat="identity", position=position_dodge(), width = 0.7) +
  scale_fill_manual(values=c("orange", "blue", "red", "pink", "black")) +
  theme_minimal() +
  theme(axis.text.x=element_text(colour="grey20",size=15),
        axis.text.y=element_text(colour="grey20", hjust=1,vjust=0.8,size=10),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Markers", y = "Gene expression (pTPM)") + 
  theme(axis.text=element_text(size=15), 
        axis.title=element_text(size=20)) + 
  labs(title = "Marker's gene expression",
       subtitle = "Differential expression among markers for white and brown adipocyte\n",
       caption = "\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=25, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=20),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(legend.position=c(0.8, 0.7),
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  guides(fill=guide_legend(title="Legend"))
 

```




#### 1.4.8.23. oligodendrocytes


"oligodendrocytes":
- oligodendrocyte, interfascicular
- oligodendrocyte, Satellite


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("oligodendrocytes")
```



```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "oligodendrocytes")
```


```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)


for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "oligodendrocytes" & df_markers[i,4] == "brain") {
  df_markers[i,1] <- "brain"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
# lymphocyte, helper T (CD4)

Oligodendrocyte_Marker_random<- sample(Oligodendrocyte_Marker, 10)

for (i in Oligodendrocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



#### 1.4.8.24. astrocytes


"astrocytes":
- astrocyte, fibrous
- astrocyte, protoplasmic (velate)


```{r}
# Visualize clusters belonging to a specific cell type

UMAPcelltype("astrocytes")
```


```{r}
#VER_TEJIDOS_POR_TIPO_CELULAR<- df_pTPM %>% subset(Cell_type == "astrocytes")
```



```{r}
ID<- df_pTPM$ID
df_markers<- df_pTPM[3:19658]
df_markers<- cbind(ID, df_markers)
Classification<- rep(NA, size=444)
df_markers<- cbind(Classification, df_markers)

for (i in seq(1:length(df_markers$Cell_type))){
  
  if (df_markers[i,3] == "astrocytes" & df_markers[i,4] == "brain") {
  df_markers[i,1] <- "brain"
  } 
  
  else {
     df_markers[i,1]<- "Other"
  }
  
}
```


```{r}
astrocyte_Marker_random<- sample(astrocyte_Marker, 10)

for (i in astrocyte_Marker_random) {
  
  if (i %in% colnames(df_markers)) {
    
    print(marker_expression_function(my_data=df_markers, my_y=df_markers[,i] , my_title=i, my_legend_title="T cells from"))
    
  }
  
  else {
    
  }
}
```



## 1.5. Hierarchical clustering




```{r}
## Data preparation

## With the following code I calculate:
# Distances (dist)
# Hierarchical tree (hc)
# Cophenetic correlation coefficient (corr_list)


metrics_gen<- c("euclidean", "manhattan", "pearson", "spearman", "7") # 7=Cosine
methods_gen<- c("ward.D2", "single", "complete", "average", "centroid")

corr_list_gen<- c()
ID_gen<- c()


for(i in metrics_gen) {
  
    if (i == "7") {
    
    # Compute distance matrix
    dist<- dist.binary(df_pTPM_data, method = i)
    
    # Save it into a variable
    name_dist<- paste("dist_gen", i, sep="_") 
    assign(name_dist, dist, envir = .GlobalEnv)
    
    } else {
  
    # Compute distance matrix
    dist<- get_dist(df_pTPM_data, method = i)
  
    # Save it into a variable
    name_dist<- paste("dist_gen", i, sep="_", collapse=NULL) 
    assign(name_dist, dist, envir = .GlobalEnv)
    
    }
    

  for(j in methods_gen) {
    
    # Cluster data in a hierarchical tree according to distance matrix
    hc <- hclust(d = dist, method = j)
   
    # Save it into a variable
    name_hc<- paste("hc_gen", i, j, sep="_", collapse=NULL) 
    assign(name_hc, hc, envir = .GlobalEnv)
    
    # Save names
    ID_gen<- c(ID_gen, name_hc)
    
    # Create dendogram object
    dend<- as.dendrogram(hc)
    
    # Save it into a variable
    name_dend<- paste("dend_gen", i, j, sep="_", collapse=NULL) 
    assign(name_dend, dend, envir = .GlobalEnv)

    # Compute cophentic distance (Coph. dist.) matrix, represents dissimilarity between instances in the dendrogram
    # Coph. dist. between two instances is defined as the height in the dendrogram where two instances are joined for the first time
    coph.dist<- cophenetic(hc)
    
    # Save it into a variable
    name_coph.dist<- paste("coph_dist_gen", i, j, sep="_", collapse=NULL) 
    assign(name_coph.dist, coph.dist, envir = .GlobalEnv)
    
    # Correlation between cophenetic distance and the original distance
    corr<- cor(dist, coph.dist)
    
    # Add correlations to a list
    corr_list_gen<-c(corr_list_gen, corr)
    
    cat(i, "&", j, "->",corr , "\n\n")
    
    }
}
```



### 1.5.1. Distance matrix cell types


The classification of observations into groups requires some methods for computing the distance or the (dis)similarity between each pair of observations. The result of this computation is known as a dissimilarity or distance matrix.


```{r}
# Visualize all distance matrices (euclidean, manhattan, pearson, spearman, maximum, canberra)

dm1<- fviz_dist(dist_gen_euclidean, show_labels = FALSE) + labs(title = "Euclidean")
dm2<- fviz_dist(dist_gen_manhattan, show_labels = FALSE) + labs(title = "Manhattan")
dm3<- fviz_dist(dist_gen_pearson, show_labels = FALSE) + labs(title = "Pearson")
dm4<- fviz_dist(dist_gen_spearman, show_labels = FALSE) + labs(title = "Spearman")
```


```{r}
figure<- ggarrange(dm1, dm2, dm3, dm4,
          ncol = 3, nrow = 2)

annotate_figure(figure,
                top = text_grob("", size = 1),
                bottom = text_grob("\nData source: Karlsson et al. (2021)", hjust = 1, x = 1, face = "italic", size = 20),
                fig.lab = "", fig.lab.face = "bold",  fig.lab.size=1
                )
```

Euclidean y Maximum no parecen distinguir muy bien los grupos. 

Trabajaré con Spearman, Pearson y Manhattan


```{r}
# Calculate melted distance matrix
melted_dm1<- melt(as.matrix(dist_gen_euclidean))
melted_dm2<- melt(as.matrix(dist_gen_manhattan))
melted_dm3<- melt(as.matrix(dist_gen_pearson))
melted_dm4<- melt(as.matrix(dist_gen_spearman))
```


```{r}
## For example
# Euclidean

#tiff("Euclidean_genedata.tiff",width=3840,height=2160)

fviz_dist(dist_gen_euclidean, show_labels = FALSE) + 
  theme(axis.text.x=element_text(colour="grey20",size=10, angle = 90, hjust = 1, vjust=0.5),
        axis.text.y=element_text(colour="grey20", size=10, hjust=1)) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  theme(legend.position="none")

#dev.off()
```



### 1.5.3. Cophenetic correlation coefficient (Rohlf, 1962)



```{r}
# Employ cophentic correlation to identify which of the linkage methods mentioned above produces the dendrogram with the highest similarity to the underlying distance matrix.

df_corr_gen <- data.frame(ID_gen, corr_list_gen)

# The numbers are indeed of type character. I need to convert them to numeric
df_corr_gen<- transform(df_corr_gen,corr_list_gen = as.numeric(corr_list_gen)) 

# Order from greater to smaller CoCC value
df_corr_gen<- arrange(df_corr_gen, desc(corr_list_gen)) 


## According to Rohlf (1988):
# very good = >0.9
# good = 0.8 - 0.9
# reasonably good = 0.7 - 0.8

Target<- c()

for (i in seq_along(corr_list_gen)){
  
  if (df_corr_gen$corr_list_gen[i] > 0.9) {
    Target<- c(Target, "Very good")
  } 
  
  if (df_corr_gen$corr_list_gen[i] > 0.8 & df_corr_gen$corr_list_gen[i] <= 0.9) {
    Target<- c(Target, "Good")
  } 
  
  if (df_corr_gen$corr_list_gen[i] > 0.7 & df_corr_gen$corr_list_gen[i] <= 0.8) {
    Target<- c(Target, "Reasonably good")
  } 
  
  if (df_corr_gen$corr_list_gen[i] <= 0.7) {
    Target<- c(Target, "Not good")
  }
}

# Add target column
df_corr_gen<- cbind(df_corr_gen, Target)
df_corr_gen<- transform(df_corr_gen, Target=as.factor(Target))

# See default levels order:
levels(df_corr_gen$Target) 
# "Good", "Not good", "Reasonably good", "Very good" 

# Specify the factor levels in the order I want
df_corr_gen$Target <- factor(df_corr_gen$Target, levels = c("Very good", "Good", "Reasonably good", "Not good"))
```


```{r}
# Visualize best coph corr

ggplot(df_corr_gen, aes(x=reorder(ID_gen, -corr_list_gen), y=corr_list_gen, fill=Target)) + 
  geom_bar(stat="identity", size=1) + 
  scale_fill_manual(values=c("deeppink", "deeppink4", "brown", "gray")) +
  theme(axis.text.x=element_text(colour="grey20",size=15),
        axis.text.y=element_text(colour="grey20", hjust=1,vjust=0.8,size=10),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Cophenetic correlation coefficient", y = "Hierarchical tree") + 
  labs(title = "Verification of the cluster tree\n",
       subtitle = "Once the dendrogram is created, we can evaluate whether its structure reflects the original distances between observations or not. This can be done by calculating the correlation coefficient between the cophenetic distances of the dendrogram and the original distance matrix. The cophentic distance between two instances is defined as the height in the dendrogram where two instances are joined for the first time, that is, the height of the nodes.",
       caption = "\nData source: Karlsson et al. (2021)") +
  theme(plot.title = element_text(hjust = 0, size=30, face = "bold"),
        plot.subtitle = element_text(hjust = 0, size=20),
        plot.caption = element_text(hjust = 1, size=15, face = "italic")) + 
  theme(legend.position= "bottom",
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  guides(fill=guide_legend(title="Rohlf (1988)",keywidth = 2, keyheight = 1, title.position = "left", title.hjust = -0.1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  coord_flip()
```




### 1.5.4. Internal validation


```{r}
set.seed(31)

## Within-cluster sum of squares
# shows how compact the clusters are for different k values.
#It assumes that we want clusters to be as compact (high cohesion, high separation) as possible.
fviz_nbclust(df_pTPM_data, kmeans, method = "wss", k.max = 40) + theme_minimal() + ggtitle("the Elbow Method")

# The Silhouette Plot
# It measures cohesion and separation based on the following indicators
fviz_nbclust(df_pTPM_data, kmeans, method = "silhouette", k.max = 40) + theme_minimal() + ggtitle("The Silhouette Plot")
```


### 1.5.4. Dendograms





```{r}
# For example
#tiff("Euclidean_average_genedata.tiff",width=3840,height=2160)

fviz_dend(hc_gen_euclidean_average,
          main = "Dendrogram\n",
          xlab = "Cell types", 
          ylab = "Euclidean", 
          sub = "Data source: Karlsson et al. (2021)", # no se para que sirve
          cex = 0.7, # label size
          horiz = FALSE)
#dev.off()
```



# 2. Compilation of functional and morphological characteristics of cell types in the scientific literature



## 2.2. Generate dataset

According to Vickarious, the following cell types have in turn subtypes: 


"adipocytes":
- adipose cell, white
- adipose cell, brown
- adipose cell, lipocyte of liver

"macrophaes":
- macrophage, alveolar
- macrophage, connective tissue
- macrophage, multinucleated
- macrophage, serous cavity
- macrophage, splenic

"b-cells":
- lymphocyte, IgA B
- lymphocyte, IgE B
- lymphocyte, IgG B
- lymphocyte, IgM B

"t-cells"
- lymphocyte, helper T (CD4)
- lymphocyte, killer T (also known as cytotoxic T cell)(CD8) 
- lymphocyte, suppressor T (also known as regulatory T cells) (CD4)


"pancreatic endocrine cells" = pancreatic endocrine cells found in islets of Langerhans
- alpha cell
- beta cell
- delta cell
- No estoy segura: chromophobic (C) cell

"enteroendocrine cells":
- gastroenteropancreatic X cell (many subtypes)

"endothelial cells":
- endothelial cell, central nervous system
- endothelial cell, continuous
- endothelial cell, corneal
- endothelial cell, fenestrated
- endothelial cell, lymphatic
- endothelial cell, splenic

"oligodendrocytes":
- oligodendrocyte, interfascicular
- oligodendrocyte, Satellite

"astrocytes":
- astrocyte, fibrous
- astrocyte, protoplasmic (velate)

"skeletal myocytes":
- muscle cell, skeletal, intermediate
- muscle cell, skeletal, red cell (slow)
- muscle cell, skeletal, white cell (fast)

"horizontal cells":
- neuron, horizontal type HI
- neuron, horizontal type HII
- neuron, horizontal type HIII

"cone photoreceptor cells":
- cone photoreceptors, blue sensitive
- cone photoreceptors, green sensitive
- cone photoreceptors, red sensitive


"bipolar cells":
- neuron, bistratified giant bipolar
- neuron, blue cone bipolar cell type a
- neuron, blue cone bipolar cell type b
- neuron, diffuse cone bipolar cell type a
- neuron, diffuse cone bipolar cell type b
- neuron, flat midget bipolar
- neuron, giant diffuse bipolar
- neuron, invaginating midget bipolar
- neuron, rod bipolar cell

goblet cell --> no hace distinción entre tracto respiratorio e intestinal

Los fibroblastos pueden ser como las neuronas, haber muchos subtipos invetsiga


```{r}
names(terms)
```


```{r}
# ---- NOTES ----

# Reference: Vickaryous & Hall (2006)


## Not included in their classification: 

#### "basal prostatic cells"
#### "basal squamous epithelial cells"
#### "basal keratinocytes"
#### "oligodendrocyte precursor cells"
#### "undifferentiated cells"

#### "spermatogonia"
#### "spermatocytes"
#### "late spermatids"
#### "early spermatids"

#### "syncytiotrophoblasts"
#### "cytotrophoblasts"
#### "extravillous trophoblasts"
#### "hofbauer cells" (placental macrophages)

#### "mixed immune cells"
#### "mixed cell types"
#### "endometrial stromal cells". The endometrial stromal layer comprises uterine fibroblasts and a mix of immune cells.

#### "ionocytes" # Its discovery was after the paper was published --> https://www.nature.com/articles/s41586-018-0394-6



## Some considerations

# No distinction between distal and proximal enterocytes
# Take into account that the white adipocyte comes from the neural crest, beside the mesoderm. But for the sake of simplification I've only indicated mesoderm.
# Data has been slightly modified because some data were redundant
# Vickarious does not differenciate between distal and proximal enterocytes

# ---------------




## Features characters

terms<- list(
  
  adipocytes= c("connective tissue", "support", "storage"), # several subtypes 
  macrophages= c("connective tissue", "blood/immune", "monocyte"), # several subtypes
  kupffer_cells= c("connective tissue", "blood/immune", "monocyte"), # same name
  monocytes= c("connective tissue", "blood/immune", "monocyte"), # same name
  t_cells= c("connective tissue", "blood/immune", "lymphocytes"), # several subtypes  
  b_cells= c("connective tissue", "blood/immune", "lymphocytes"), # several subtypes  
  granulocytes= c("connective tissue", "blood/immune", "leukocyte"), # leukocyte, granulocyte 
  erythroid_cells= c("connective tissue", "blood/immune", "other"), # erythrocyte 
  nk_cells= c("connective tissue", "blood/immune", "lymphocytes"), # lymphocyte, killer cell 
  dendritic_cells= c("connective tissue", "blood/immune", "monocyte"), # same name 
  langerhans_cells= c("connective tissue", "blood/immune", "monocyte"), # Langerhans cell, epidermis 
  plasma_cells= c("connective tissue", "blood/immune", "lymphocytes"), # same name 
  pancreatic_endocrine_cells= c("epithelial tissue-somatic", "gland", "endocrine-non-pituitary"), # alpha, beta, delta and chromophobic cells; common features
  leydig_cells= c("epithelial tissue-somatic", "gland", "endocrine-non-pituitary", "steroid"), # same name
  enteroendocrine_cells= c("epithelial tissue-somatic", "gland", "endocrine-non-pituitary", "peptide"), # several subtypes (e.g., gastroenteropancreatic X cell)
  theca_cells= c("epithelial tissue-somatic", "gland", "endocrine-non-pituitary", "steroid"), # theca interna cell
  exocrine_glandular_cells= c("epithelial tissue-somatic", "gland", "exocrine", "protein secreting"), # acinar cell 
  prostatic_glandular_cells= c("epithelial tissue-somatic", "gland", "exocrine", "other"), # gland cell, prostate
  gastric_mucus_secreting_cells= c("epithelial tissue-somatic", "gland", "exocrine", "mucous"), # secretory stomach cell
  paneth_cells= c("epithelial tissue-somatic", "gland", "exocrine", "protein secreting"), # same name
  club_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # Clara cell
  respiratory_ciliated_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # epithelial cell, respiratory, ciliated cell 
  intestinal_goblet_cells= c("epithelial tissue-somatic", "gland", "exocrine", "mucous"), # goblet cell
  breast_glandular_cells= c("epithelial tissue-somatic", "gland", "exocrine", "sweat"), # gland cell, mammary
  breast_myoepithelial_cells= c("muscle tissue", "non-skeletal"), # myoepithelial cell
  basal_respiratory_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # epithelial cell, respiratory, basal cell
  glandular_and_luminal_cells= c("epithelial tissue-somatic", "gland", "exocrine", "other"), # secretory endometrial cell
  endothelial_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "endothelial cell"), # several subtypes
  muller_glia_cells= c("nervous tissue", "glia-central nervous system", "astrocytes"), # Muller cell
  oligodendrocytes= c("nervous tissue", "glia-central nervous system", "oligodendrocytes"), # several subtypes
  astrocytes= c("nervous tissue", "glia-central nervous system", "astrocytes"), # several subtypes
  microglial_cells= c("connective tissue", "blood/immune", "monocyte"), # microglia
  fibroblasts= c("connective tissue", "support", "ECM secreting"), # same name
  hepatic_stellate_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "endolymphatic cells"), # stellate cell, perilymphatic space lining
  peritubular_cells= c("muscle tissue", "non-skeletal"), # recall that it is a modified myofibroblastic cells
  cardiomyocytes= c("muscle tissue", "non-skeletal"), # muscle cell, cardiac fibre
  smooth_muscle_cells= c("muscle tissue", "non-skeletal"), # muscle cell, smooth
  skeletal_myocytes= c("muscle tissue", "skeletal-myocyte"), # several subtypes
  horizontal_cells= c("nervous tissue", "neuron", "central nervous system-special (visual) sensory"), # several subtypes
  cone_photoreceptor_cells= c("nervous tissue", "neuron", "central nervous system-special (visual) sensory"), # several subtypes
  rod_photoreceptor_cells= c("nervous tissue", "neuron", "central nervous system-special (visual) sensory"), # rod cell
  bipolar_cells= c("nervous tissue", "neuron", "central nervous system-special (visual) sensory"), # several subtypes
  excitatory_neurons= c("nervous tissue", "neuron", "peripheral nervous system"), # neuron, enteric, motor, excitatory
  inhibitory_neurons= c("nervous tissue", "neuron", "peripheral nervous system"), # neuron, enteric, motor, inhibitory
  melanocytes= c("epithelial tissue-somatic", "surface epithelium", "covering", "non-keratinizing"), # same name
  squamous_epithelial_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # epithelial cell, stratified squamous
  suprabasal_keratinocytes= c("epithelial tissue-somatic", "surface epithelium", "covering", "keratinizing"), # keratinocytes
  pancreatic_ductal_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # centroacinar cells
  collecting_duct_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # duct cell, collecting tubule
  urothelial_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # epithelial cell, transitional
  hepatocytes= c("epithelial tissue-somatic", "gland", "exocrine", "other"), # same name
  cholangiocytes= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # duct cell, bile duct
  alveolar_cells_type_2= c("epithelial tissue-somatic", "gland", "exocrine", "protein secreting"), # pneumocyte, type II, great alveolar cell (septal cell)
  alveolar_cells_type_1= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # pneumocyte, type I
  proximal_tubular_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # epithelial cell, proximal tubule
  distal_tubular_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # epithelial cell, distal tubule
  sertoli_cells= c("epithelial tissue-somatic", "gland", "endocrine-non-pituitary", "peptide"), # same name
  endometrial_ciliated_cells= c("epithelial tissue-somatic", "surface epithelium", "lining", "ducts"), # ciliated female reproductive cell
  proximal_enterocytes= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # brush border cell, intestine (with microvilli)
  distal_enterocytes= c("epithelial tissue-somatic", "surface epithelium", "lining", "hollow viscera"), # brush border cell, intestine (with microvilli)
  granulosa_cells= c("epithelial tissue-somatic", "gland", "endocrine-non-pituitary", "steroid") # follicle cell
)
```


```{r}
# Get cell type names and all terms
cell_types<- names(terms)
all_terms<- c()

for (i in cell_types) {
  all_terms<- c(all_terms, terms[[i]])
}


# Create empty matrix
df_VH<- data.frame(matrix(0, length(terms), length(unique(all_terms))))
colnames(df_VH)<- unique(all_terms)
rownames(df_VH)<- cell_types


# Fill it
for (i in cell_types) {
  for (j in seq(1:length(terms[[i]]))) {
    
    df_VH[i, terms[[i]][j]]<-1
  }
}
```


```{r}
# Check if a column is full of ones
which(apply(df_VH, 2, function(x) length(unique(x))) == 1)
```



## 2.3. Exploratory Data Analysis



```{r}
# Dimensions
cat(bold("Dimensions: \n\n"), "Rows: ", nrow(df_VH), "\n", "Columns: ", ncol(df_VH), "\n\n")

# Values taken by the data
cat(bold("Type of data:"), "binary,", range(df_VH), "\n\n")

# Count cases for each abundance class
ab<- table(unlist(df_VH))
cat(bold("Abundancies:\n"))
ab

# Barplot of the distribution, all species confounded
barplot(ab, xlab = "Abundance class", ylab = "Frequency")

# INTERPRET THE HIGH FREQUENCY OF ZEROS IN THE DATA FRAME

# Descriptive statistics per column
summary(df_VH)

# COMPARE MEDIAN AND MEAN ABUNDANCES. ARE MOST DISTRIBUTIONS SYMETRICAL?
```


## 2.4. Hierarchical clustering


```{r}
# Jaccard dissimilarity matrix 
dist_jaccard_1<- dist.binary(df_VH, method = 1) 
#dist_jaccard_2<- vegdist(df_VH) 
dist_jaccard_3<- dist(df_VH, "binary") # argument "binary" produces (1 − Jaccard)

# Sorensen/Dice dissimilarity matrix 
dist_sorensen_1<- dist.binary(df_VH, method = 5) 
#dist_sorensen_2<- vegdist(df_VH, binary=TRUE) 

# Ochiai dissimilarity matrix
dist_ochiai<- dist.binary(df_VH, method = 7)

# Euclidean distance
dist_euclidean_1<- dist(df_VH, method = "euclidean")
dist_euclidean_2<- get_dist(df_VH, method = "euclidean")

```


```{r}
# Check that the outputs are not identical

#setequal(dist_jaccard_1, dist_jaccard_2)
setequal(dist_jaccard_1, dist_jaccard_3)
#setequal(dist_jaccard_3, dist_jaccard_2)

#setequal(dist_sorensen_1, dist_sorensen_2)

setequal(dist_euclidean_1, dist_euclidean_2)
```


```{r}
set.seed(123)



metrics_Vi<-  c("spearman", "pearson", "euclidean", "manhattan", "5", "1", "7") #5=Sørensen-Dice, 1=Jaccard, 7=Cosine
methods_Vi<- c("ward.D2", "single", "complete", "average", "centroid")


ID_corr_Vi<- c()
corr_list_Vi<- c()


for (i in metrics_Vi) {
  
  if (i == "5" | i == "1" | i == "7") {
    
    dist<- dist.binary(df_VH, method = i)
    
    # Save it into a variable
    name_dist<- paste("dist_Vi", i, sep="_") 
    assign(name_dist, dist, envir = .GlobalEnv)
    
  } else {
   
    dist<- get_dist(df_VH, method = i) 
   
    # Save it into a variable
    name_dist<- paste("dist_Vi", i, sep="_", collapse=NULL) 
    assign(name_dist, dist, envir = .GlobalEnv)
    
  }
  
  for(j in methods_Vi) {
    
    # Cluster data in a hierarchical tree according to distance matrix values
    hc <- hclust(d = dist, method = j)
    
    # Save it into a variable
    name_hc<- paste("hc_Vi", i, j, sep="_", collapse=NULL) 
    assign(name_hc, hc, envir = .GlobalEnv)
    
    # Create dendogram
    dend<- as.dendrogram(hc)
    
    # Save it into a variable
    name_dend<- paste("dend_Vi", i, j, sep="_", collapse=NULL) 
    assign(name_dend, dend, envir = .GlobalEnv)

    # Calculate Cophentic distance matrix
    coph.dist<- cophenetic(hc)
    
    # Save it into a variable
    name_coph.dist<- paste("coph_dist_Vi", i, j, sep="_", collapse=NULL) 
    assign(name_coph.dist, coph.dist, envir = .GlobalEnv)
    
    # Correlation between cophenetic distance and the original distance
    corr<- cor(dist, coph.dist)
    
    # Save it into a variable
    name_corr<- paste("corr_coph_Vi", i, j, sep="_", collapse=NULL) 
    assign(name_corr, corr, envir = .GlobalEnv)
    
    # Add to a list
    corr_list_Vi<-c(corr_list_Vi, corr)
    
    
    # Save ID's
    ID_corr_Vi<- c(ID_corr_Vi, name_corr)
  }
} 
```


### 2.4.1. Distance matrix

The classification of observations into groups requires some methods for computing the distance or the (dis)similarity between each pair of observations. The result of this computation is known as a dissimilarity or distance matrix.


```{r}
dm_pearson<- fviz_dist(dist_Vi_pearson, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Pearson")


dm_spearman<- fviz_dist(dist_Vi_spearman, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Spearman")


dm_euclidean<- fviz_dist(dist_Vi_euclidean, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Euclidean")


dm_manhattan<- fviz_dist(dist_Vi_manhattan, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Manhattan")


dm_dice<- fviz_dist(dist_Vi_1, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Sørensen-Dice")


dm_jaccard<- fviz_dist(dist_Vi_5, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Jaccard")


dm_ochiai<- fviz_dist(dist_Vi_7, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Cosine")


figure<- ggarrange(dm_pearson, dm_spearman, dm_euclidean, dm_manhattan, dm_dice, dm_jaccard, dm_ochiai,
          ncol = 2, nrow = 4)


annotate_figure(figure,
                top = text_grob("", face = "bold", size = 1),
                bottom = text_grob("\nData source: Karlsson et al. (2021)", hjust = 1, x = 1, face = "italic", size = 10),
                fig.lab = "", fig.lab.face = "bold",  fig.lab.size=1
                )
```


```{r}
# Calculate melted distance matrix to get access to exact distances
melted_dm1<- melt(as.matrix(dist_Vi_euclidean))
melted_dm1<- melt(as.matrix(dist_Vi_manhattan))
melted_dm2<- melt(as.matrix(dist_Vi_1))
melted_dm3<- melt(as.matrix(dist_Vi_5))
melted_dm4<- melt(as.matrix(dist_Vi_7))
melted_dm5<- melt(as.matrix(dist_Vi_pearson))
melted_dm6<- melt(as.matrix(dist_Vi_spearman))
```


```{r}
# For example
#tiff("Euclidean_Vickaryous.tiff",width=3840,height=2160)

fviz_dist(dist_Vi_euclidean, show_labels = FALSE) + 
  theme(axis.text.x=element_text(colour="grey20",size=40, angle = 90, hjust = 1, vjust=0.5),
        axis.text.y=element_text(colour="grey20", size=40, hjust=1)) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  theme(legend.position="none")

#dev.off()
```



### 2.4.2. Cophenetic correlation coefficient (Rohlf, 1962)



```{r}
# Employ cophentic correlation to identify which of the linkage methods mentioned above produces the dendrogram with the highest similarity to the underlying distance matrix.

df_corr_Vi <- data.frame(ID_corr_Vi, corr_list_Vi)

# The numbers are indeed of type character. I need to convert them to numeric
df_corr_Vi<- transform(df_corr_Vi,corr_list_Vi = as.numeric(corr_list_Vi)) 

# Order from greater to smaller CoCC value
df_corr_Vi<- arrange(df_corr_Vi, desc(corr_list_Vi)) 


## According to Rohlf (1988):
# very good = >0.9
# good = 0.8 - 0.9
# reasonably good = 0.7 - 0.8

Target<- c()

for (i in seq_along(corr_list_Vi)){
  
  if (df_corr_Vi$corr_list_Vi[i] > 0.9) {
    Target<- c(Target, "Very good")
  } 
  
  if (df_corr_Vi$corr_list_Vi[i] > 0.8 & df_corr_Vi$corr_list_Vi[i] <= 0.9) {
    Target<- c(Target, "Good")
  } 
  
  if (df_corr_Vi$corr_list_Vi[i] > 0.7 & df_corr_Vi$corr_list_Vi[i] <= 0.8) {
    Target<- c(Target, "Reasonably good")
  } 
  
  if (df_corr_Vi$corr_list_Vi[i] <= 0.7) {
    Target<- c(Target, "Not good")
  }
}

# Add target column
df_corr_Vi<- cbind(df_corr_Vi, Target)
df_corr_Vi<- transform(df_corr_Vi, Target=as.factor(Target))

# See default levels order:
levels(df_corr_Vi$Target) 
# "Good", "Not good", "Reasonably good", "Very good" 

# Specify the factor levels in the order I want
df_corr_Vi$Target <- factor(df_corr_Vi$Target, levels = c("Very good", "Good", "Reasonably good", "Not good"))
```


```{r}
# Visualize best coph corr

ggplot(df_corr_Vi, aes(x=reorder(ID_corr_Vi, -corr_list_Vi), y=corr_list_Vi, fill=Target)) + 
  geom_bar(stat="identity", size=1) + 
  scale_fill_manual(values=c("deeppink", "deeppink4", "brown", "gray")) +
  theme(axis.text.x=element_text(colour="grey20",size=15),
        axis.text.y=element_text(colour="grey20", hjust=1,vjust=0.8,size=10),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Hierarchical tree\n\n", y = "\n\nCophenetic correlation coefficient\n\n") + 
  theme(legend.position= "bottom",
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  guides(fill=guide_legend(title="Rohlf (1988)",keywidth = 2, keyheight = 1, title.position = "left", title.hjust = -0.1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  coord_flip()
```





### 2.4.3. Index of Agreement


According to Willmot the index of agreement “is not a measure of correlation or association in the formal sense, but rather a measure of the degree to which a model’s predictions are error free.”. An index of agreement of 1 indicates perfect agreement, whilst a value of 0 indicates complete disagreement.

```{r}
## The Index of Agreement is a measure of the degree to which a model’s predictions are error free.”. 
# An index of agreement of 1 indicates perfect agreement, whilst a value of 0 indicates complete disagreement.
# I calculate their mean

IoA_Vi<- c()
IoA_Vi_ID<- c("IoA_jaccard_complete_Vi", "IoA_jaccard_ward.D2_Vi", "IoA_jaccard_single_Vi", "IoA_jaccard_average_Vi", "IoA_jaccard_centroid_co","IoA_dice_complete_Vi", "IoA_dice_ward.D2_Vi", "IoA_dice_single_Vi", "IoA_dice_average_Vi", "IoA_dice_centroid_co",  "IoA_Visine_complete_Vi", "IoA_Visine_ward.D2_Vi", "IoA_Visine_single_Vi", "IoA_Visine_average_Vi", "IoA_Visine_centroid_co", "IoA_euclidean_complete_Vi", "IoA_euclidean_ward.D2_Vi", "IoA_euclidean_single_Vi", "IoA_euclidean_average_Vi", "IoA_euclidean_centroid_co", "IoA_spearman_complete_Vi", "IoA_spearman_ward.D2_Vi", "IoA_spearman_single_Vi", "IoA_spearman_average_Vi", "IoA_spearman_centroid_co", "IoA_pearson_complete_Vi", "IoA_pearson_ward.D2_Vi", "IoA_pearson_single_Vi", "IoA_pearson_average_Vi", "IoA_pearson_centroid_co", "IoA_manhattan_complete_Vi", "IoA_manhattan_ward.D2_Vi", "IoA_manhattan_single_Vi", "IoA_manhattan_average_Vi", "IoA_manhattan_centroid_co")

## Jaccard

IoA_jaccard_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_1_complete), as.matrix(dist_Vi_1), na.rm = FALSE)))
IoA_jaccard_complete_Vi_mean<- colMeans(IoA_jaccard_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_jaccard_complete_Vi_mean)

IoA_jaccard_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_1_ward.D2), as.matrix(dist_Vi_1), na.rm = FALSE)))
IoA_jaccard_ward.D2_Vi_mean<- colMeans(IoA_jaccard_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_jaccard_ward.D2_Vi_mean)

IoA_jaccard_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_1_single), as.matrix(dist_Vi_1), na.rm = FALSE)))
IoA_jaccard_single_Vi_mean<- colMeans(IoA_jaccard_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_jaccard_single_Vi_mean)

IoA_jaccard_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_1_average), as.matrix(dist_Vi_1), na.rm = FALSE)))
IoA_jaccard_average_Vi_mean<- colMeans(IoA_jaccard_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_jaccard_average_Vi_mean)

IoA_jaccard_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_1_centroid), as.matrix(dist_Vi_1), na.rm = FALSE)))
IoA_jaccard_centroid_co_mean<- colMeans(IoA_jaccard_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_jaccard_centroid_co_mean)


## Dice
IoA_dice_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_5_complete), as.matrix(dist_Vi_5), na.rm = FALSE)))
IoA_dice_complete_Vi_mean<- colMeans(IoA_dice_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_dice_complete_Vi_mean)

IoA_dice_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_5_ward.D2), as.matrix(dist_Vi_5), na.rm = FALSE)))
IoA_dice_ward.D2_Vi_mean<- colMeans(IoA_dice_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_dice_ward.D2_Vi_mean)

IoA_dice_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_5_single), as.matrix(dist_Vi_5), na.rm = FALSE)))
IoA_dice_single_Vi_mean<- colMeans(IoA_dice_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_dice_single_Vi_mean)

IoA_dice_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_5_average), as.matrix(dist_Vi_5), na.rm = FALSE)))
IoA_dice_average_Vi_mean<- colMeans(IoA_dice_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_dice_average_Vi_mean)

IoA_dice_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_5_centroid), as.matrix(dist_Vi_5), na.rm = FALSE)))
IoA_dice_centroid_co_mean<- colMeans(IoA_dice_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_dice_centroid_co_mean)


## Cosine
IoA_Visine_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_7_complete), as.matrix(dist_Vi_7), na.rm = FALSE)))
IoA_Visine_complete_Vi_mean<- colMeans(IoA_Visine_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_Visine_complete_Vi_mean)

IoA_Visine_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_7_ward.D2), as.matrix(dist_Vi_7), na.rm = FALSE)))
IoA_Visine_ward.D2_Vi_mean<- colMeans(IoA_Visine_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_Visine_ward.D2_Vi_mean)

IoA_Visine_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_7_single), as.matrix(dist_Vi_7), na.rm = FALSE)))
IoA_Visine_single_Vi_mean<- colMeans(IoA_Visine_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_Visine_single_Vi_mean)

IoA_Visine_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_7_average), as.matrix(dist_Vi_7), na.rm = FALSE)))
IoA_Visine_average_Vi_mean<- colMeans(IoA_Visine_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_Visine_average_Vi_mean)

IoA_Visine_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_7_centroid), as.matrix(dist_Vi_7), na.rm = FALSE)))
IoA_Visine_centroid_co_mean<- colMeans(IoA_Visine_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_Visine_centroid_co_mean)


# Euclidean
IoA_euclidean_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_euclidean_complete), as.matrix(dist_Vi_euclidean), na.rm = FALSE)))
IoA_euclidean_complete_Vi_mean<- colMeans(IoA_euclidean_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_euclidean_complete_Vi_mean)

IoA_euclidean_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_euclidean_ward.D2), as.matrix(dist_Vi_euclidean), na.rm = FALSE)))
IoA_euclidean_ward.D2_Vi_mean<- colMeans(IoA_euclidean_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_euclidean_ward.D2_Vi_mean)

IoA_euclidean_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_euclidean_single), as.matrix(dist_Vi_euclidean), na.rm = FALSE)))
IoA_euclidean_single_Vi_mean<- colMeans(IoA_euclidean_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_euclidean_single_Vi_mean)

IoA_euclidean_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_euclidean_average), as.matrix(dist_Vi_euclidean), na.rm = FALSE)))
IoA_euclidean_average_Vi_mean<- colMeans(IoA_euclidean_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_euclidean_average_Vi_mean)

IoA_euclidean_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_euclidean_centroid), as.matrix(dist_Vi_euclidean), na.rm = FALSE)))
IoA_euclidean_centroid_co_mean<- colMeans(IoA_euclidean_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_euclidean_centroid_co_mean)

## Spearman
IoA_spearman_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_spearman_complete), as.matrix(dist_Vi_spearman), na.rm = FALSE)))
IoA_spearman_complete_Vi_mean<- colMeans(IoA_spearman_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_spearman_complete_Vi_mean)

IoA_spearman_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_spearman_ward.D2), as.matrix(dist_Vi_spearman), na.rm = FALSE)))
IoA_spearman_ward.D2_Vi_mean<- colMeans(IoA_spearman_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_spearman_ward.D2_Vi_mean)

IoA_spearman_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_spearman_single), as.matrix(dist_Vi_spearman), na.rm = FALSE)))
IoA_spearman_single_Vi_mean<- colMeans(IoA_spearman_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_spearman_single_Vi_mean)

IoA_spearman_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_spearman_average), as.matrix(dist_Vi_spearman), na.rm = FALSE)))
IoA_spearman_average_Vi_mean<- colMeans(IoA_spearman_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_spearman_average_Vi_mean)

IoA_spearman_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_spearman_centroid), as.matrix(dist_Vi_spearman), na.rm = FALSE)))
IoA_spearman_centroid_co_mean<- colMeans(IoA_spearman_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_spearman_centroid_co_mean)

## Pearson
IoA_pearson_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_pearson_complete), as.matrix(dist_Vi_pearson), na.rm = FALSE)))
IoA_pearson_complete_Vi_mean<- colMeans(IoA_pearson_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_pearson_complete_Vi_mean)

IoA_pearson_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_pearson_ward.D2), as.matrix(dist_Vi_pearson), na.rm = FALSE)))
IoA_pearson_ward.D2_Vi_mean<- colMeans(IoA_pearson_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_pearson_ward.D2_Vi_mean)

IoA_pearson_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_pearson_single), as.matrix(dist_Vi_pearson), na.rm = FALSE)))
IoA_pearson_single_Vi_mean<- colMeans(IoA_pearson_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_pearson_single_Vi_mean)

IoA_pearson_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_pearson_average), as.matrix(dist_Vi_pearson), na.rm = FALSE)))
IoA_pearson_average_Vi_mean<- colMeans(IoA_pearson_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_pearson_average_Vi_mean)

IoA_pearson_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_pearson_centroid), as.matrix(dist_Vi_pearson), na.rm = FALSE)))
IoA_pearson_centroid_co_mean<- colMeans(IoA_pearson_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_pearson_centroid_co_mean)

## Manhattan
IoA_manhattan_complete_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_manhattan_complete), as.matrix(dist_Vi_manhattan), na.rm = FALSE)))
IoA_manhattan_complete_Vi_mean<- colMeans(IoA_manhattan_complete_Vi)
IoA_Vi<- c(IoA_Vi, IoA_manhattan_complete_Vi_mean)

IoA_manhattan_ward.D2_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_manhattan_ward.D2), as.matrix(dist_Vi_manhattan), na.rm = FALSE)))
IoA_manhattan_ward.D2_Vi_mean<- colMeans(IoA_manhattan_ward.D2_Vi)
IoA_Vi<- c(IoA_Vi, IoA_manhattan_ward.D2_Vi_mean)

IoA_manhattan_single_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_manhattan_single), as.matrix(dist_Vi_manhattan), na.rm = FALSE)))
IoA_manhattan_single_Vi_mean<- colMeans(IoA_manhattan_single_Vi)
IoA_Vi<- c(IoA_Vi, IoA_manhattan_single_Vi_mean)

IoA_manhattan_average_Vi<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_manhattan_average), as.matrix(dist_Vi_manhattan), na.rm = FALSE)))
IoA_manhattan_average_Vi_mean<- colMeans(IoA_manhattan_average_Vi)
IoA_Vi<- c(IoA_Vi, IoA_manhattan_average_Vi_mean)

IoA_manhattan_centroid_co<- as.data.frame(sort(d(as.matrix(coph_dist_Vi_manhattan_centroid), as.matrix(dist_Vi_manhattan), na.rm = FALSE)))
IoA_manhattan_centroid_co_mean<- colMeans(IoA_manhattan_centroid_co)
IoA_Vi<- c(IoA_Vi, IoA_manhattan_centroid_co_mean)
```


```{r}
df_IoA_Vi <- data.frame(IoA_Vi_ID, IoA_Vi)

# The numbers are indeed of type character. I need to convert them to numeric
df_IoA_Vi<- transform(df_IoA_Vi,IoA_Vi = as.numeric(IoA_Vi)) 

# Order from greater to smaller CoCC value
df_IoA_Vi<- arrange(df_IoA_Vi, desc(IoA_Vi)) 


# very good = >0.9
# good = 0.8 - 0.9
# reasonably good = 0.7 - 0.8

Target<- c()

for (i in seq_along(IoA_Vi)){
  
  if (df_IoA_Vi$IoA_Vi[i] > 0.9) {
    Target<- c(Target, "Very good")
  } 
  
  if (df_IoA_Vi$IoA_Vi[i] > 0.8 & df_IoA_Vi$IoA_Vi[i] <= 0.9) {
    Target<- c(Target, "Good")
  } 
  
  if (df_IoA_Vi$IoA_Vi[i] > 0.7 & df_IoA_Vi$IoA_Vi[i] <= 0.8) {
    Target<- c(Target, "Reasonably good")
  } 
  
  if (df_IoA_Vi$IoA_Vi[i] <= 0.7) {
    Target<- c(Target, "Not good")
  }
}

# Add target column
df_IoA_Vi<- cbind(df_IoA_Vi, Target)
df_IoA_Vi<- transform(df_IoA_Vi, Target=as.factor(Target))

# See default levels order:
levels(df_IoA_Vi$Target) 
# "Good", "Not good", "Reasonably good", "Very good" 

# Specify the factor levels in the order I want
df_IoA_Vi$Target <- factor(df_IoA_Vi$Target, levels = c("Very good", "Good", "Reasonably good", "Not good"))
```


### 2.4.4. Dendrograms


Vickarious classification:


1. Epithelial tissue (32), 12 o 13 subdivisiones


"Gland" 

      "exocrine" 

            "mucous

- "B", # gastric_mucus_secreting_cells, endoderm
- "B", # intestinal_goblet_cells, endoderm

            "protein secreting"
             
- "C", # exocrine_glandular_cells, endoderm
- "C", # paneth_cells, endoderm
- "C", # alveolar_cells_type_2, endoderm

            "sweat"
             
- "D", # breast_glandular_cells, ectoderm
           
           
            "other"

- "E", # glandular_and_luminal_cells, mesoderm
- "E", # prostatic_glandular_cells, endoderm
- "E", # hepatocytes, endoderm


      "endocrine-non-pituitary"

- "J" # pancreatic_endocrine_cells, endoderm
           
            "peptide"

- "I", # sertoli_cells, mesoderm
- "I", # enteroendocrine_cells, endoderm

   
            "steroid"
             
- "K", # leydig_cells, mesoderm
- "K", # theca_cells, mesoderm
- "K", # granulosa_cells, mesoderm



"surface epithelium"


      "covering"
      
            "keratinizing"
             
- "L", # suprabasal_keratinocytes, ectoderm

            "non-keratinizing"
            
- "M", # melanocytes, neural crest




      "lining"
      
            "ducts"
    
- "O", # endometrial_ciliated_cells, mesoderm
- "O", # proximal_tubular_cells, mesoderm
- "O", # distal_tubular_cells, mesoderm
- "O", # collecting_duct_cells, mesoderm
- "O", # ductal_cells, endoderm
- "O", # urothelial_cells, endoderm
- "O", # cholangiocytes, endoderm


    "hollow viscera"
    
    
- "P", # enterocytes, endoderm (PROXIMAL)
- "P", # enterocytes, endoderm (DISTAL)
- "P", # club_cells, endoderm
- "P", # respiratory_ciliated_cells, endoderm
- "P", # squamous_epithelial_cells, endoderm, ectoderm
- "P", # alveolar_cells_type_1, endoderm
- "P", # basal_respiratory_cells, endoderm
   
    "endothelial cell"
    
- "Q", # endothelial_cells, mesoderm

      "endolymphatic cells"
    
- "S", # hepatic_stellate_cells, ectoderm




2. Connective tissue (14), 6 subdivisiones
  
"support"


      "storage"
- "T", # adipocytes, mesoderm
        
      "ECM secreting"
       
- "U", # fibroblasts, mesoderm, neural crest


"blood/immune"

    "lymphocytes"

- "V", # t_cells, endoderm
- "V", # b_cells, endoderm
- "V", # nk_cells, mesoderm
- "V", # plasma_cells, mesoderm
    
    "monocyte"
    
- "W", # macrophages, mesoderm
- "W", # kupffer_cells, mesoderm
- "W", # monocytes, mesoderm
- "W", # dendritic_cells, mesoderm
- "W", # langerhans_cells, mesoderm
- "W", # microglial_cells, mesoderm
   
   "leukocyte"
   
- "X", # granulocytes, mesoderm

    "other"
             
- "Y", # erythroid_cells, mesoderm
 
 

3. Nervous tissue (9), 4 subdivisiones
 
 "glia-central nervous system"
 
        "astrocytes"
 
- "AA", # muller_glia_cells, ectoderm
- "AA", # astrocytes, ectoderm

        "oligodendrocytes"
             
- "BB", # oligodendrocytes, ectoderm

"neuron"

      "peripheral nervous system"
      
- "CC", # excitatory_neurons, neural crest
- "CC", # inhibitory_neurons, neural crest

        "central nervous system (special (visual) sensory)"
        
- "DD", # horizontal_cells, ectoderm
- "DD", # cone_photoreceptor_cells, ectoderm
- "DD", # rod_photoreceptor_cells, ectoderm
- "DD", # bipolar_cells, ectoderm
  


4. Muscle tissue (5), 2 subdivisiones
 
 
 "skeletal-myocyte"
 
- "FF", # skeletal_myocytes, mesoderm

"non-skeletal"

- "HH", # cardiomyocytes, mesoderm
- "HH", # smooth_muscle_cells, mesoderm
- "HH", # peritubular_cells, mesoderm
- "HH", # breast_myoepithelial_cells, ectoderm


#### 2.4.4.1. Jaccard



```{r}
## 4 clusters
tiff("k4_average_jaccard.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_1_average, 
          main = "Jaccard - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_single, 
          main = "Jaccard - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_ward.D2, 
          main = "Jaccard - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()

tiff("k4_complete_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_complete, 
          main = "Jaccard - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.935, linetype = "dashed")
dev.off()

tiff("k4_centroid_jaccard.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_1_centroid, 
          main = "Jaccard - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```


```{r}
clusters_hc_Vi_1_average<- cutree(hc_Vi_1_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_1_average)

cat("\n\n")
clusters_hc_Vi_1_single<- cutree(hc_Vi_1_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_single)

cat("\n\n")
clusters_hc_Vi_1_ward.D2<- cutree(hc_Vi_1_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_ward.D2)

cat("\n\n")
clusters_hc_Vi_1_complete<- cutree(hc_Vi_1_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_complete)

cat("\n\n")
clusters_hc_Vi_1_centroid <- cutree(hc_Vi_1_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_centroid)
```



```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("epithelial tissue", "connective tissue", "muscle tissue", "nervous tissue")
truth_1 <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_1_average <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_1_complete <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_1_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("epithelial tissue", "nervous tissue", "muscle tissue", "connective tissue")
truth_3 <- factor(rep(lvs_3, times = c(33, 9, 5, 14)), levels = rev(lvs_3))
pred_hc_Vi_1_ward.D2 <- factor(rep(lvs_3, times = c(15, 18, 14, 14)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_1_average<- confusionMatrix(table(pred_hc_Vi_1_average, truth_1))
cm_hc_Vi_1_single<- confusionMatrix(pred_hc_Vi_1_single, truth_2)
cm_hc_Vi_1_ward.D2<- confusionMatrix(pred_hc_Vi_1_ward.D2, truth_3)
cm_hc_Vi_1_complete<- confusionMatrix(pred_hc_Vi_1_complete, truth_1)
```


```{r}
cm_hc_Vi_1_average$overall
cm_hc_Vi_1_average$table
cm_hc_Vi_1_average$byClass

as.data.frame(t(cm_hc_Vi_1_average$byClass)[5:7,])
```


```{r}
cm_hc_Vi_1_single$overall
cm_hc_Vi_1_single$table
cm_hc_Vi_1_single$byClass

as.data.frame(t(cm_hc_Vi_1_single$byClass)[5:7,])
```


```{r}
cm_hc_Vi_1_ward.D2$overall
cm_hc_Vi_1_ward.D2$table
cm_hc_Vi_1_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_1_ward.D2$byClass)[5:7,])
```


```{r}
cm_hc_Vi_1_complete$overall
cm_hc_Vi_1_complete$table
cm_hc_Vi_1_complete$byClass

as.data.frame(t(cm_hc_Vi_1_complete$byClass)[5:7,])
```

```{r}
Accuracy_k4<- c(cm_hc_Vi_1_average$overall[1], cm_hc_Vi_1_single$overall[1], cm_hc_Vi_1_ward.D2$overall[1], cm_hc_Vi_1_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_1_average$overall[2], cm_hc_Vi_1_single$overall[2], cm_hc_Vi_1_ward.D2$overall[2], cm_hc_Vi_1_complete$overall[2])
```


Vemos que **Complete** y **Average** son los mejores métodos en diferenciar los cuatro grandes grupos, epithelial, connective tissue", muscle y nervous tissues, con unas puntuaciones excelentes. Esto ya nos da una pista de cuales van a reprsentar mejor los 24-25 clusteres en los que se deberían de incluir todos los tipos celulares según Vickarious. Por otro lado, los que no distinguen bien los cuatro grupos son Ward y Single. 



```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_average, 
          main = "Jaccard - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_single, 
          main = "Jaccard - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_ward.D2, 
          main = "Jaccard - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_complete, 
          main = "Jaccard - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_jaccard.tiff",width=1720,height=880)
fviz_dend(hc_Vi_1_centroid, 
          main = "Jaccard - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```


```{r}
clusters_hc_Vi_1_average<- cutree(hc_Vi_1_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_average)

cat("\n\n")
clusters_hc_Vi_1_single<- cutree(hc_Vi_1_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_single)

cat("\n\n")
clusters_hc_Vi_1_ward.D2<- cutree(hc_Vi_1_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_ward.D2)

cat("\n\n")
clusters_hc_Vi_1_complete<- cutree(hc_Vi_1_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_complete)

cat("\n\n")
clusters_hc_Vi_1_centroid <- cutree(hc_Vi_1_centroid, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_1_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
# I think it does a better classification with 25 clusters (including the group "J") because k=24 groups clusters "I", "K" and "J" together.
truth_1 <- c(rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1),rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_1_average <-  c(rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1),rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))# distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# Cuando indicas que te diferencie 25 clusteres, te junta el tipo celular problemático ("J") con el grupo "K". Ademas de que no consigue distinguirlo, tampoco tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("C", 3), rep("E", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_1_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("C", 3), rep("E", 3), rep("B", 2), rep("D", 1), rep("K", 6), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("I", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
truth_3 <- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3), rep("O", 7), rep("S", 1), rep("Q", 1), rep("L", 1), rep("M", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6))

pred_hc_Vi_1_ward.D2<-  c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 3), rep("K", 3), rep("O", 6), rep("J", 1), rep("S", 1), rep("Q", 1), rep("L", 1), rep("M", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6))# distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
truth_4 <- c(rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V", 4), rep("W",6 ), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_1_complete<-  c(rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2), rep("V", 4), rep("W",6 ), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))# de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_1_average<- confusionMatrix(table(pred_hc_Vi_1_average, truth_1))
cm_hc_Vi_1_single<- confusionMatrix(table(pred_hc_Vi_1_single, truth_2))
cm_hc_Vi_1_ward.D2<- confusionMatrix(table(pred_hc_Vi_1_ward.D2, truth_3))
cm_hc_Vi_1_complete<- confusionMatrix(table(pred_hc_Vi_1_complete, truth_4))
```


```{r}
cm_hc_Vi_1_average$overall
cm_hc_Vi_1_average$table
cm_hc_Vi_1_average$byClass

as.data.frame(t(cm_hc_Vi_1_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_1_single$overall
cm_hc_Vi_1_single$table
cm_hc_Vi_1_single$byClass

as.data.frame(t(cm_hc_Vi_1_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_1_ward.D2$overall
cm_hc_Vi_1_ward.D2$table
cm_hc_Vi_1_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_1_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_1_complete$overall
cm_hc_Vi_1_complete$table
cm_hc_Vi_1_complete$byClass

as.data.frame(t(cm_hc_Vi_1_complete$byClass)[5:7,])

```

```{r}
Accuracy_k25<- c(cm_hc_Vi_1_average$overall[1], cm_hc_Vi_1_single$overall[1], cm_hc_Vi_1_ward.D2$overall[1], cm_hc_Vi_1_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_1_average$overall[2], cm_hc_Vi_1_single$overall[2], cm_hc_Vi_1_ward.D2$overall[2], cm_hc_Vi_1_complete$overall[2])
```



De nuevo **Average** y **Complete** son los que mejor score tienen, junto con **Ward**. Sin embargo, Ward recordemos que no era bueno distinguiendo los cuatro grandes grupos de procedencia de tejido. Si bien es el mejor situando a urothelial cerca de su verdadero grupo ("O"). Aunque Single tiene también una buena score, recordemos que tampoco es capaz de hacer la disitnción básica de tejido de procedencia.

Voy a compara los métodos Average y Complete:

**Compare dendrograms visually**. I will compare dendrograms using the dendextend R package. The dendextend package provides several functions for comparing dendrograms. I will particularly focus on  tanglegram() for visual comparison, which plots the two dendrograms, side by side, with their labels connected by lines, and cor.dendlist() for computing a correlation matrix between dendrograms.

The quality of the alignment of the two trees can be measured using the function entanglement(). Entanglement is a measure between 1 (full entanglement) and 0 (no entanglement). A lower entanglement coefficient corresponds to a good alignment.


```{r}
# Create a list to hold the two dendrograms to cpmpare
 
dend_average<- as.dendrogram(hc_Vi_1_average)
dend_complete<- as.dendrogram(hc_Vi_1_complete)

dend_list <- dendlist("Average" = dend_average, 
                      "Complete" = dend_complete)

## Visual comparison
# Note that "unique" nodes, with a combination of labels/items not present in the other tree, are highlighted with dashed lines
tanglegram(dend_average, dend_complete,
           highlight_distinct_edges = TRUE, # dashed lines
           common_subtrees_color_lines = TRUE, # line colors
           common_subtrees_color_branches = TRUE, # Color common branches
           main = paste("entanglement =", round(entanglement(dend_list), 2))
           )
```


Vemos que son parecidísimos, simplemente cambia el orden de los dos subconjuntos de epithelium tissue. Elegiré **Complete** porque es el que guarda el orden más parecido con Vickarious.


#### 2.4.4.2. Dice

```{r}
fviz_dend(hc_Vi_5_complete, 
          main = "dice - Complete", 
          xlab = "",  ylab = "", 
          cex = 0.5, 
          lwd = 1,
          horiz = TRUE,
          k = 4, k_colors = c("#df1ad3", "#fe8300", "#162d9f", "#39a84e"))
```



```{r}
## 4 clusters
tiff("k4_average_dice.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_5_average, 
          main = "dice - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_single, 
          main = "dice - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_ward.D2, 
          main = "dice - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()


fviz_dend(hc_Vi_5_complete, 
          main = "dice - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
          

tiff("k4_centroid_dice.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_5_centroid, 
          main = "dice - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```


```{r}
clusters_hc_Vi_5_average<- cutree(hc_Vi_5_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_5_average)

cat("\n\n")
clusters_hc_Vi_5_single<- cutree(hc_Vi_5_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_single)

cat("\n\n")
clusters_hc_Vi_5_ward.D2<- cutree(hc_Vi_5_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_ward.D2)

cat("\n\n")
clusters_hc_Vi_5_complete<- cutree(hc_Vi_5_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_complete)

cat("\n\n")
clusters_hc_Vi_5_centroid <- cutree(hc_Vi_5_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_centroid)
```


```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("epithelial tissue", "connective tissue", "muscle tissue", "nervous tissue")
truth_1 <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_5_average <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_5_complete <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_5_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("epithelial tissue", "nervous tissue", "muscle tissue", "connective tissue")
truth_3 <- factor(rep(lvs_3, times = c(33, 9, 5, 14)), levels = rev(lvs_3))
pred_hc_Vi_5_ward.D2 <- factor(rep(lvs_3, times = c(15, 18, 14, 14)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_5_average<- confusionMatrix(table(pred_hc_Vi_5_average, truth_1))
cm_hc_Vi_5_single<- confusionMatrix(pred_hc_Vi_5_single, truth_2)
cm_hc_Vi_5_ward.D2<- confusionMatrix(pred_hc_Vi_5_ward.D2, truth_3)
cm_hc_Vi_5_complete<- confusionMatrix(pred_hc_Vi_5_complete, truth_1)
```


```{r}
cm_hc_Vi_5_average$overall
cm_hc_Vi_5_average$table
cm_hc_Vi_5_average$byClass

as.data.frame(t(cm_hc_Vi_5_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_5_single$overall
cm_hc_Vi_5_single$table
cm_hc_Vi_5_single$byClass

as.data.frame(t(cm_hc_Vi_5_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_5_ward.D2$overall
cm_hc_Vi_5_ward.D2$table
cm_hc_Vi_5_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_5_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_5_complete$overall
cm_hc_Vi_5_complete$table
cm_hc_Vi_5_complete$byClass

as.data.frame(t(cm_hc_Vi_5_complete$byClass)[5:7,])

```


```{r}
Accuracy_k4<- c(cm_hc_Vi_5_average$overall[1], cm_hc_Vi_5_single$overall[1], cm_hc_Vi_5_ward.D2$overall[1], cm_hc_Vi_5_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_5_average$overall[2], cm_hc_Vi_5_single$overall[2], cm_hc_Vi_5_ward.D2$overall[2], cm_hc_Vi_5_complete$overall[2])
```


Vemos que **Complete** y **Average** son los mejores métodos en diferenciar los cuatro grandes grupos, epithelial, connective tissue", muscle y nervous tissues, con unas puntuaciones excelentes. Esto ya nos da una pista de cuales van a reprsentar mejor los 24-25 clusteres en los que se deberían de incluir todos los tipos celulares según Vickarious.



```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_average, 
          main = "dice - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_single, 
          main = "dice - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_ward.D2, 
          main = "dice - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_complete, 
          main = "dice - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_dice.tiff",width=1720,height=880)
fviz_dend(hc_Vi_5_centroid, 
          main = "dice - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```


```{r}
clusters_hc_Vi_5_average<- cutree(hc_Vi_5_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_average)

cat("\n\n")
clusters_hc_Vi_5_single<- cutree(hc_Vi_5_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_single)

cat("\n\n")
clusters_hc_Vi_5_ward.D2<- cutree(hc_Vi_5_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_ward.D2)

cat("\n\n")
clusters_hc_Vi_5_complete<- cutree(hc_Vi_5_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_complete)

cat("\n\n")
clusters_hc_Vi_5_centroid <- cutree(hc_Vi_5_centroid, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_5_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
# I think it does a better classification with 25 clusters (including the group "J") because k=24 groups clusters "I", "K" and "J" together.
truth_1 <- c(rep("P", 7), rep("Q",1 ), rep("S", 1), rep("O", 7), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB",1 ))

pred_hc_Vi_5_average <-  c(rep("P", 7), rep("Q",1 ), rep("S", 1), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB",1 )) # distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# no tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1),  rep("E", 3),rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3),  rep("L", 1),rep("M", 1),  rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_5_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1),  rep("E", 3),rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 6),  rep("L", 1),rep("M", 1),  rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 6),rep("I", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
truth_3 <- c(rep("B", 2), rep("D", 1),  rep("C", 3),rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3),rep("O", 7), rep("L", 1), rep("M", 1), rep("S", 1), rep("Q", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA",2 ), rep("BB",1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1),rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6))

pred_hc_Vi_5_ward.D2<- c(rep("B", 2), rep("D", 1),  rep("C", 3),rep("E", 3), rep("I", 3), rep("K", 3),rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("S", 1), rep("Q", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA",2 ), rep("BB",1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1),rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6)) # distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
truth_4 <- c(rep("L", 1), rep("M",1 ), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("E", 3), rep("C", 3), rep("B",2 ), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V",4 ), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB",1 ))

pred_hc_Vi_5_complete<- c(rep("L", 1), rep("M",1 ), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6),rep("J", 1), rep("E", 3), rep("C", 3), rep("B",2 ), rep("D", 1), rep("K", 4),  rep("I", 2), rep("V",4 ), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB",1 )) # de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_5_average<- confusionMatrix(table(pred_hc_Vi_5_average, truth_1))
cm_hc_Vi_5_single<- confusionMatrix(table(pred_hc_Vi_5_single, truth_2))
cm_hc_Vi_5_ward.D2<- confusionMatrix(table(pred_hc_Vi_5_ward.D2, truth_3))
cm_hc_Vi_5_complete<- confusionMatrix(table(pred_hc_Vi_5_complete, truth_4))
```


```{r}
cm_hc_Vi_5_average$overall
cm_hc_Vi_5_average$table
cm_hc_Vi_5_average$byClass

as.data.frame(t(cm_hc_Vi_5_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_5_single$overall
cm_hc_Vi_5_single$table
cm_hc_Vi_5_single$byClass

as.data.frame(t(cm_hc_Vi_5_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_5_ward.D2$overall
cm_hc_Vi_5_ward.D2$table
cm_hc_Vi_5_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_5_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_5_complete$overall
cm_hc_Vi_5_complete$table
cm_hc_Vi_5_complete$byClass

as.data.frame(t(cm_hc_Vi_5_complete$byClass)[5:7,])

```



```{r}
Accuracy_k25<- c(cm_hc_Vi_5_average$overall[1], cm_hc_Vi_5_single$overall[1], cm_hc_Vi_5_ward.D2$overall[1], cm_hc_Vi_5_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_5_average$overall[2], cm_hc_Vi_5_single$overall[2], cm_hc_Vi_5_ward.D2$overall[2], cm_hc_Vi_5_complete$overall[2])
```


De nuevo **Average** y **Complete** son los que mejor score tienen,junto con **Ward**. Sin embargo, Ward recordemos que no era bueno distinguiendo los cuatro grandes grupos de procedencia de tejido. Si bien es el mejor situando a urothelial cerca de su verdadero grupo ("O").  Aunque Single tiene también una buena score, recordemos que tampoco es capaz de hacer la disitnción básica de tejido de procedencia.

Voy a compara los métodos Average y Complete:


```{r}
# Create a list to hold the two dendrograms to cpmpare
 
dend_average<- as.dendrogram(hc_Vi_5_average)
dend_complete<- as.dendrogram(hc_Vi_5_complete)

dend_list <- dendlist("Average" = dend_average, 
                      "Complete" = dend_complete)

## Visual comparison
# Note that "unique" nodes, with a combination of labels/items not present in the other tree, are highlighted with dashed lines
tanglegram(dend_average, dend_complete,
           highlight_distinct_edges = TRUE, # dashed lines
           common_subtrees_color_lines = TRUE, # line colors
           common_subtrees_color_branches = TRUE, # Color common branches
           main = paste("entanglement =", round(entanglement(dend_list), 2))
           )
```


Vemos que son parecidísimos, simplemente cambia el orden de los dos subconjuntos de epithelium tissue. Elegiré **Complete** porque es el que guarda el orden más parecido con Vickarious.


#### 2.4.4.3. Cosine

```{r}
## 4 clusters
tiff("k4_average_cosine.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_7_average, 
          main = "cosine - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_single, 
          main = "cosine - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_ward.D2, 
          main = "cosine - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()

tiff("k4_complete_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_complete, 
          main = "cosine - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.935, linetype = "dashed")
dev.off()

tiff("k4_centroid_cosine.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_7_centroid, 
          main = "cosine - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```



```{r}
clusters_hc_Vi_7_average<- cutree(hc_Vi_7_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_7_average)

cat("\n\n")
clusters_hc_Vi_7_single<- cutree(hc_Vi_7_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_single)

cat("\n\n")
clusters_hc_Vi_7_ward.D2<- cutree(hc_Vi_7_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_ward.D2)

cat("\n\n")
clusters_hc_Vi_7_complete<- cutree(hc_Vi_7_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_complete)

cat("\n\n")
clusters_hc_Vi_7_centroid <- cutree(hc_Vi_7_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_centroid)
```


```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("epithelial tissue", "connective tissue", "muscle tissue", "nervous tissue")
truth_1 <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_7_average <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_7_complete <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_7_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("epithelial tissue", "nervous tissue", "muscle tissue", "connective tissue")
truth_3 <- factor(rep(lvs_3, times = c(33, 9, 5, 14)), levels = rev(lvs_3))
pred_hc_Vi_7_ward.D2 <- factor(rep(lvs_3, times = c(15, 18, 14, 14)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_7_average<- confusionMatrix(table(pred_hc_Vi_7_average, truth_1))
cm_hc_Vi_7_single<- confusionMatrix(pred_hc_Vi_7_single, truth_2)
cm_hc_Vi_7_ward.D2<- confusionMatrix(pred_hc_Vi_7_ward.D2, truth_3)
cm_hc_Vi_7_complete<- confusionMatrix(pred_hc_Vi_7_complete, truth_1)
```


```{r}
cm_hc_Vi_7_average$overall
cm_hc_Vi_7_average$table
cm_hc_Vi_7_average$byClass

as.data.frame(t(cm_hc_Vi_7_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_7_single$overall
cm_hc_Vi_7_single$table
cm_hc_Vi_7_single$byClass

as.data.frame(t(cm_hc_Vi_7_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_7_ward.D2$overall
cm_hc_Vi_7_ward.D2$table
cm_hc_Vi_7_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_7_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_7_complete$overall
cm_hc_Vi_7_complete$table
cm_hc_Vi_7_complete$byClass

as.data.frame(t(cm_hc_Vi_7_complete$byClass)[5:7,])

```

```{r}
Accuracy_k4<- c(cm_hc_Vi_7_average$overall[1], cm_hc_Vi_7_single$overall[1], cm_hc_Vi_7_ward.D2$overall[1], cm_hc_Vi_7_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_7_average$overall[2], cm_hc_Vi_7_single$overall[2], cm_hc_Vi_7_ward.D2$overall[2], cm_hc_Vi_7_complete$overall[2])
```

Vemos que **Complete** y **Average** son los mejores métodos en diferenciar los cuatro grandes grupos, epithelial, connective tissue", muscle y nervous tissues, con unas puntuaciones excelentes. Esto ya nos da una pista de cuales van a reprsentar mejor los 24-25 clusteres en los que se deberían de incluir todos los tipos celulares según Vickarious.

```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_average, 
          main = "cosine - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_single, 
          main = "cosine - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_ward.D2, 
          main = "cosine - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_complete, 
          main = "cosine - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_cosine.tiff",width=1720,height=880)
fviz_dend(hc_Vi_7_centroid, 
          main = "cosine - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```


```{r}
clusters_hc_Vi_7_average<- cutree(hc_Vi_7_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_average)

cat("\n\n")
clusters_hc_Vi_7_single<- cutree(hc_Vi_7_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_single)

cat("\n\n")
clusters_hc_Vi_7_ward.D2<- cutree(hc_Vi_7_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_ward.D2)

cat("\n\n")
clusters_hc_Vi_7_complete<- cutree(hc_Vi_7_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_complete)

cat("\n\n")
clusters_hc_Vi_7_centroid <- cutree(hc_Vi_7_centroid, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_7_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
# I think it does a better classification with 25 clusters (including the group "J") because k=24 groups clusters "I", "K" and "J" together.
truth_1 <- c(rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1),rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_7_average <- c(rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1),rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# no tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1),rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_7_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 6),  rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1),rep("O", 6),rep("I", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
truth_3 <- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3), rep("O", 7),  rep("L", 1), rep("M", 1),rep("S", 1), rep("Q", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6))

pred_hc_Vi_7_ward.D2<- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 3), rep("K", 3), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1),rep("S", 1), rep("Q", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6)) # distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
truth_4 <- c(rep("L", 1), rep("M",1 ),rep("P", 7),rep("Q", 1),rep("S", 1),rep("O", 7),rep("E", 3),rep("C", 3),rep("B", 2),rep("D", 1),rep("K", 3),rep("J",1 ),rep("I", 2),rep("V", 4),rep("W", 6),rep("X", 1),rep("Y", 1),rep("U", 1),rep("T", 1),rep("HH", 4),rep("FF",1 ),rep("CC",2 ),rep("DD", 4),rep("AA", 2),rep("BB", 1))

pred_hc_Vi_7_complete<- c(rep("L", 1), rep("M",1 ),rep("P", 7),rep("Q", 1),rep("S", 1),rep("O", 6), rep("J",1 ), rep("E", 3),rep("C", 3),rep("B", 2),rep("D", 1),rep("K", 4),rep("I", 2),rep("V", 4),rep("W", 6),rep("X", 1),rep("Y", 1),rep("U", 1),rep("T", 1),rep("HH", 4),rep("FF",1 ),rep("CC",2 ),rep("DD", 4),rep("AA", 2),rep("BB", 1))# de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_7_average<- confusionMatrix(table(pred_hc_Vi_7_average, truth_1))
cm_hc_Vi_7_single<- confusionMatrix(table(pred_hc_Vi_7_single, truth_2))
cm_hc_Vi_7_ward.D2<- confusionMatrix(table(pred_hc_Vi_7_ward.D2, truth_3))
cm_hc_Vi_7_complete<- confusionMatrix(table(pred_hc_Vi_7_complete, truth_4))
```


```{r}
cm_hc_Vi_7_average$overall
cm_hc_Vi_7_average$table
cm_hc_Vi_7_average$byClass

as.data.frame(t(cm_hc_Vi_7_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_7_single$overall
cm_hc_Vi_7_single$table
cm_hc_Vi_7_single$byClass

as.data.frame(t(cm_hc_Vi_7_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_7_ward.D2$overall
cm_hc_Vi_7_ward.D2$table
cm_hc_Vi_7_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_7_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_7_complete$overall
cm_hc_Vi_7_complete$table
cm_hc_Vi_7_complete$byClass

as.data.frame(t(cm_hc_Vi_7_complete$byClass)[5:7,])

```


```{r}
Accuracy_k25<- c(cm_hc_Vi_7_average$overall[1], cm_hc_Vi_7_single$overall[1], cm_hc_Vi_7_ward.D2$overall[1], cm_hc_Vi_7_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_7_average$overall[2], cm_hc_Vi_7_single$overall[2], cm_hc_Vi_7_ward.D2$overall[2], cm_hc_Vi_7_complete$overall[2])
```


De nuevo **Average** y **Complete** son los que mejor score tienen,junto con **Ward**. Sin embargo, Ward recordemos que no era bueno distinguiendo los cuatro grandes grupos de procedencia de tejido. Si bien es el mejor situando a urothelial cerca de su verdadero grupo ("O").  Aunque Single tiene también una buena score, recordemos que tampoco es capaz de hacer la disitnción básica de tejido de procedencia.

Voy a compara los métodos Average y Complete:


```{r}
# Create a list to hold the two dendrograms to cpmpare
 
dend_average<- as.dendrogram(hc_Vi_7_average)
dend_complete<- as.dendrogram(hc_Vi_7_complete)

dend_list <- dendlist("Average" = dend_average, 
                      "Complete" = dend_complete)

## Visual comparison
# Note that "unique" nodes, with a combination of labels/items not present in the other tree, are highlighted with dashed lines
tanglegram(dend_average, dend_complete,
           highlight_distinct_edges = TRUE, # dashed lines
           common_subtrees_color_lines = TRUE, # line colors
           common_subtrees_color_branches = TRUE, # Color common branches
           main = paste("entanglement =", round(entanglement(dend_list), 2))
           )
```


Vemos que son parecidísimos, simplemente cambia el orden de los dos subconjuntos de epithelium tissue. Elegiré **Complete** porque es el que guarda el orden más parecido con Vickarious.


#### 2.4.4.4. Euclidean


```{r}
## 4 clusters
tiff("k4_average_euclidean.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_euclidean_average, 
          main = "euclidean - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_single, 
          main = "euclidean - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_ward.D2, 
          main = "euclidean - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()

tiff("k4_complete_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_complete, 
          main = "euclidean - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.935, linetype = "dashed")
dev.off()

tiff("k4_centroid_euclidean.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_euclidean_centroid, 
          main = "euclidean - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```


```{r}
clusters_hc_Vi_euclidean_average<- cutree(hc_Vi_euclidean_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_euclidean_average)

cat("\n\n")
clusters_hc_Vi_euclidean_single<- cutree(hc_Vi_euclidean_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_single)

cat("\n\n")
clusters_hc_Vi_euclidean_ward.D2<- cutree(hc_Vi_euclidean_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_ward.D2)

cat("\n\n")
clusters_hc_Vi_euclidean_complete<- cutree(hc_Vi_euclidean_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_complete)

cat("\n\n")
clusters_hc_Vi_euclidean_centroid <- cutree(hc_Vi_euclidean_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_centroid)
```


```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("epithelial tissue", "connective tissue", "muscle tissue", "nervous tissue")
truth_1 <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_euclidean_average <- factor(rep(lvs_1, times = c(18, 15, 19, 9)), levels = rev(lvs_1)) # este método es muchísimo peor con esta distancia que con las tres anteriores
pred_hc_Vi_euclidean_complete <- factor(rep(lvs_1, times = c(18, 15, 19, 9)), levels = rev(lvs_1)) # este método es muchísimo peor con esta distancia que con las tres anteriores

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_euclidean_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("epithelial tissue", "nervous tissue", "muscle tissue", "connective tissue")
truth_3 <- factor(rep(lvs_3, times = c(33, 9, 5, 14)), levels = rev(lvs_3))
pred_hc_Vi_euclidean_ward.D2 <- factor(rep(lvs_3, times = c(15, 18, 14, 14)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_euclidean_average<- confusionMatrix(table(pred_hc_Vi_euclidean_average, truth_1))
cm_hc_Vi_euclidean_single<- confusionMatrix(pred_hc_Vi_euclidean_single, truth_2)
cm_hc_Vi_euclidean_ward.D2<- confusionMatrix(pred_hc_Vi_euclidean_ward.D2, truth_3)
cm_hc_Vi_euclidean_complete<- confusionMatrix(pred_hc_Vi_euclidean_complete, truth_1)
```


```{r}
cm_hc_Vi_euclidean_average$overall
cm_hc_Vi_euclidean_average$table
cm_hc_Vi_euclidean_average$byClass

as.data.frame(t(cm_hc_Vi_euclidean_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_euclidean_single$overall
cm_hc_Vi_euclidean_single$table
cm_hc_Vi_euclidean_single$byClass

as.data.frame(t(cm_hc_Vi_euclidean_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_euclidean_ward.D2$overall
cm_hc_Vi_euclidean_ward.D2$table
cm_hc_Vi_euclidean_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_euclidean_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_euclidean_complete$overall
cm_hc_Vi_euclidean_complete$table
cm_hc_Vi_euclidean_complete$byClass

as.data.frame(t(cm_hc_Vi_euclidean_complete$byClass)[5:7,])

```


```{r}
Accuracy_k4<- c(cm_hc_Vi_euclidean_average$overall[1], cm_hc_Vi_euclidean_single$overall[1], cm_hc_Vi_euclidean_ward.D2$overall[1], cm_hc_Vi_euclidean_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_euclidean_average$overall[2], cm_hc_Vi_euclidean_single$overall[2], cm_hc_Vi_euclidean_ward.D2$overall[2], cm_hc_Vi_euclidean_complete$overall[2])
```


Ninguno de los métodos hace una correcta distinción de los cuatro grupos. Esto nos da una pista de que esta distancia no va a ser la más acertada.

```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_average, 
          main = "euclidean - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_single, 
          main = "euclidean - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_ward.D2, 
          main = "euclidean - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_complete, 
          main = "euclidean - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_euclidean.tiff",width=1720,height=880)
fviz_dend(hc_Vi_euclidean_centroid, 
          main = "euclidean - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```


```{r}
clusters_hc_Vi_euclidean_average<- cutree(hc_Vi_euclidean_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_average)

cat("\n\n")
clusters_hc_Vi_euclidean_single<- cutree(hc_Vi_euclidean_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_single)

cat("\n\n")
clusters_hc_Vi_euclidean_ward.D2<- cutree(hc_Vi_euclidean_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_ward.D2)

cat("\n\n")
clusters_hc_Vi_euclidean_complete<- cutree(hc_Vi_euclidean_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_complete)

cat("\n\n")
clusters_hc_Vi_euclidean_centroid <- cutree(hc_Vi_euclidean_centroid, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_euclidean_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
# There is no alternative for k=24.
truth_1 <- c(rep("S",1 ), rep("Q", 1),rep("O", 6),rep("P", 7),rep("O", 1),rep("L", 1),rep("M", 1),rep("E", 3),rep("C", 3),rep("B", 2),rep("D", 1),rep("K",3 ),rep("J",1 ),rep("I", 2),rep("V",4 ),rep("W", 6),rep("X", 1),rep("Y", 1),rep("U", 1),rep("T", 1),rep("HH", 4),rep("FF", 1),rep("CC", 2),rep("DD", 4),rep("AA", 2),rep("BB", 2))


pred_hc_Vi_euclidean_average <- c(rep("S",1 ), rep("Q", 1),rep("O", 6),rep("P", 7),rep("J", 1),rep("L", 1),rep("M", 1),rep("E", 3),rep("C", 3),rep("B", 2),rep("D", 1),rep("K",4 ), rep("I", 2),rep("V",4 ),rep("W", 6),rep("X", 1),rep("Y", 1),rep("U", 1),rep("T", 1),rep("HH", 4),rep("FF", 1),rep("CC", 2),rep("DD", 4),rep("AA", 2),rep("BB", 2)) # distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# no tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_euclidean_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 6),  rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 6), rep("I", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
# There is no posibility of k=24
truth_3 <- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3), rep("O", 7), rep("L", 1), rep("M", 1), rep("S", 1), rep("Q", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6))

pred_hc_Vi_euclidean_ward.D2<- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 3), rep("K", 3), rep("O", 6),  rep("J", 1), rep("L", 1), rep("M", 1), rep("S", 1), rep("Q", 1), rep("P", 7), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("U", 1), rep("T", 1), rep("W", 6)) # distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
# si no pongo nada, es que no hay posibilidad de 24
truth_4 <- c(rep("L", 1), rep("M", 1),rep("P", 7),rep("Q", 1),rep("S", 1),rep("O", 7),rep("E", 3),rep("C", 3),rep("B", 2),rep("D", 1),rep("K", 3),rep("J", 1),rep("I", 2),rep("V", 4),rep("W", 6),rep("X", 1),rep("Y", 1),rep("U", 1),rep("T", 1),rep("HH", 4),rep("FF", 1),rep("CC", 2),rep("DD", 4),rep("AA", 2),rep("BB", 1))

pred_hc_Vi_euclidean_complete<- c(rep("L", 1), rep("M", 1),rep("P", 7),rep("Q", 1),rep("S", 1),rep("O", 6), rep("J", 1),rep("E", 3),rep("C", 3),rep("B", 2),rep("D", 1),rep("K", 4),rep("I", 2),rep("V", 4),rep("W", 6),rep("X", 1),rep("Y", 1),rep("U", 1),rep("T", 1),rep("HH", 4),rep("FF", 1),rep("CC", 2),rep("DD", 4),rep("AA", 2),rep("BB", 1)) # de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_euclidean_average<- confusionMatrix(table(pred_hc_Vi_euclidean_average, truth_1))
cm_hc_Vi_euclidean_single<- confusionMatrix(table(pred_hc_Vi_euclidean_single, truth_2))
cm_hc_Vi_euclidean_ward.D2<- confusionMatrix(table(pred_hc_Vi_euclidean_ward.D2, truth_3))
cm_hc_Vi_euclidean_complete<- confusionMatrix(table(pred_hc_Vi_euclidean_complete, truth_4))
```


```{r}
cm_hc_Vi_euclidean_average$overall
cm_hc_Vi_euclidean_average$table
cm_hc_Vi_euclidean_average$byClass

as.data.frame(t(cm_hc_Vi_euclidean_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_euclidean_single$overall
cm_hc_Vi_euclidean_single$table
cm_hc_Vi_euclidean_single$byClass

as.data.frame(t(cm_hc_Vi_euclidean_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_euclidean_ward.D2$overall
cm_hc_Vi_euclidean_ward.D2$table
cm_hc_Vi_euclidean_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_euclidean_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_euclidean_complete$overall
cm_hc_Vi_euclidean_complete$table
cm_hc_Vi_euclidean_complete$byClass

as.data.frame(t(cm_hc_Vi_euclidean_complete$byClass)[5:7,])

```


```{r}
Accuracy_k25<- c(cm_hc_Vi_euclidean_average$overall[1], cm_hc_Vi_euclidean_single$overall[1], cm_hc_Vi_euclidean_ward.D2$overall[1], cm_hc_Vi_euclidean_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_euclidean_average$overall[2], cm_hc_Vi_euclidean_single$overall[2], cm_hc_Vi_euclidean_ward.D2$overall[2], cm_hc_Vi_euclidean_complete$overall[2])
```


De nuevo **Average** y **Complete** son los que mejor score tienen,junto con **Ward**. Ward sigue siendo el mejor situando a urothelial cerca de su verdadero grupo ("O").  Sin embargo, ninguno hace una buena distinción de los cuatro grandes grupos, así que descartaré esta métrica.


#### 2.4.4.5. Pearson


```{r}
## 4 clusters
tiff("k4_average_pearson.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_pearson_average, 
          main = "pearson - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_single, 
          main = "pearson - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_ward.D2, 
          main = "pearson - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()

tiff("k4_complete_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_complete, 
          main = "pearson - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.935, linetype = "dashed")
dev.off()

tiff("k4_centroid_pearson.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_pearson_centroid, 
          main = "pearson - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```


```{r}
clusters_hc_Vi_pearson_average<- cutree(hc_Vi_pearson_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_pearson_average)

cat("\n\n")
clusters_hc_Vi_pearson_single<- cutree(hc_Vi_pearson_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_single)

cat("\n\n")
clusters_hc_Vi_pearson_ward.D2<- cutree(hc_Vi_pearson_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_ward.D2)

cat("\n\n")
clusters_hc_Vi_pearson_complete<- cutree(hc_Vi_pearson_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_complete)

cat("\n\n")
clusters_hc_Vi_pearson_centroid <- cutree(hc_Vi_pearson_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_centroid)
```


```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("connective tissue", "muscle tissue", "nervous tissue", "epithelial tissue")
truth_1 <- factor(rep(lvs_1, times = c(14, 5, 9, 33)), levels = rev(lvs_1))
pred_hc_Vi_pearson_average <- factor(rep(lvs_1, times = c(14, 5, 9, 33)), levels = rev(lvs_1))
pred_hc_Vi_pearson_complete <- factor(rep(lvs_1, times = c(14, 5, 9, 33)), levels = rev(lvs_1))

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_pearson_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("nervous tissue", "muscle tissue", "connective tissue", "epithelial tissue")
truth_3 <- factor(rep(lvs_3, times = c(9, 5, 14, 33)), levels = rev(lvs_3))
pred_hc_Vi_pearson_ward.D2 <- factor(rep(lvs_3, times = c(14, 14, 15, 18)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_pearson_average<- confusionMatrix(table(pred_hc_Vi_pearson_average, truth_1))
cm_hc_Vi_pearson_single<- confusionMatrix(pred_hc_Vi_pearson_single, truth_2)
cm_hc_Vi_pearson_ward.D2<- confusionMatrix(pred_hc_Vi_pearson_ward.D2, truth_3)
cm_hc_Vi_pearson_complete<- confusionMatrix(pred_hc_Vi_pearson_complete, truth_1)
```

```{r}
cm_hc_Vi_pearson_average$overall
cm_hc_Vi_pearson_average$table
cm_hc_Vi_pearson_average$byClass

as.data.frame(t(cm_hc_Vi_pearson_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_pearson_single$overall
cm_hc_Vi_pearson_single$table
cm_hc_Vi_pearson_single$byClass

as.data.frame(t(cm_hc_Vi_pearson_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_pearson_ward.D2$overall
cm_hc_Vi_pearson_ward.D2$table
cm_hc_Vi_pearson_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_pearson_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_pearson_complete$overall
cm_hc_Vi_pearson_complete$table
cm_hc_Vi_pearson_complete$byClass

as.data.frame(t(cm_hc_Vi_pearson_complete$byClass)[5:7,])

```

```{r}
Accuracy_k4<- c(cm_hc_Vi_pearson_average$overall[1], cm_hc_Vi_pearson_single$overall[1], cm_hc_Vi_pearson_ward.D2$overall[1], cm_hc_Vi_pearson_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_pearson_average$overall[2], cm_hc_Vi_pearson_single$overall[2], cm_hc_Vi_pearson_ward.D2$overall[2], cm_hc_Vi_pearson_complete$overall[2])
```

Vemos que ningún método diferencia bien los cuatro grupos realmente. Es cierto que el número de cell types por cluster es correcto para **Complete** y **Average**, pero si nos fijamos veremos que empieza la clasificación anidando de dos en dos, de manera que por un lado está epitelial y por otro connective, muscle y nervous. Luego este ultimo grupo se divide en nervous y en otro grupo que engloba muscle y connective.


```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_average, 
          main = "pearson - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_single, 
          main = "pearson - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_ward.D2, 
          main = "pearson - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_complete, 
          main = "pearson - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_pearson.tiff",width=1720,height=880)
fviz_dend(hc_Vi_pearson_centroid, 
          main = "pearson - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```


```{r}
clusters_hc_Vi_pearson_average<- cutree(hc_Vi_pearson_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_average)

cat("\n\n")
clusters_hc_Vi_pearson_single<- cutree(hc_Vi_pearson_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_single)

cat("\n\n")
clusters_hc_Vi_pearson_ward.D2<- cutree(hc_Vi_pearson_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_ward.D2)

cat("\n\n")
clusters_hc_Vi_pearson_complete<- cutree(hc_Vi_pearson_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_complete)

cat("\n\n")
clusters_hc_Vi_pearson_centroid <- cutree(hc_Vi_pearson_centroid, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_pearson_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
truth_1 <- c(rep("V", 4), rep("X", 1), rep("Y", 1), rep("W", 6), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 1), rep("BB", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2),  rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2))

pred_hc_Vi_pearson_average <- c(rep("V", 4), rep("X", 1), rep("Y", 1), rep("W", 6), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 1), rep("BB", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2),  rep("D", 1), rep("K", 4),  rep("I", 2)) # distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# no tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3), rep("L", 1), rep("M", 1),  rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_pearson_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 6), rep("L", 1), rep("M", 1),  rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 6), rep("I", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
truth_3 <- c(rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("W", 6), rep("U", 1), rep("T", 1), rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3), rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 7), rep("L", 1), rep("M", 1))


pred_hc_Vi_pearson_ward.D2<- c(rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("W", 6), rep("U", 1), rep("T", 1), rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 3),  rep("K", 3), rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1)) # distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
truth_4 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2))

pred_hc_Vi_pearson_complete<-  c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2))
# de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_pearson_average<- confusionMatrix(table(pred_hc_Vi_pearson_average, truth_1))
cm_hc_Vi_pearson_single<- confusionMatrix(table(pred_hc_Vi_pearson_single, truth_2))
cm_hc_Vi_pearson_ward.D2<- confusionMatrix(table(pred_hc_Vi_pearson_ward.D2, truth_3))
cm_hc_Vi_pearson_complete<- confusionMatrix(table(pred_hc_Vi_pearson_complete, truth_4))
```


```{r}
cm_hc_Vi_pearson_average$overall
cm_hc_Vi_pearson_average$table
cm_hc_Vi_pearson_average$byClass

as.data.frame(t(cm_hc_Vi_pearson_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_pearson_single$overall
cm_hc_Vi_pearson_single$table
cm_hc_Vi_pearson_single$byClass

as.data.frame(t(cm_hc_Vi_pearson_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_pearson_ward.D2$overall
cm_hc_Vi_pearson_ward.D2$table
cm_hc_Vi_pearson_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_pearson_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_pearson_complete$overall
cm_hc_Vi_pearson_complete$table
cm_hc_Vi_pearson_complete$byClass

as.data.frame(t(cm_hc_Vi_pearson_complete$byClass)[5:7,])

```


```{r}
Accuracy_k25<- c(cm_hc_Vi_pearson_average$overall[1], cm_hc_Vi_pearson_single$overall[1], cm_hc_Vi_pearson_ward.D2$overall[1], cm_hc_Vi_pearson_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_pearson_average$overall[2], cm_hc_Vi_pearson_single$overall[2], cm_hc_Vi_pearson_ward.D2$overall[2], cm_hc_Vi_pearson_complete$overall[2])
```


De nuevo **Average** y **Complete** son los que mejor score tienen,junto con **Ward**. Ward es el mejor situando a urothelial cerca de su verdadero grupo ("O").

Sin embargo, como ninguno hace una correcta clasificación de los cuatro grupos, descartaré esta métrica.



#### 2.4.4.6. Spearman


```{r}
## 4 clusters
tiff("k4_average_spearman.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_spearman_average, 
          main = "spearman - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_single, 
          main = "spearman - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_ward.D2, 
          main = "spearman - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()

tiff("k4_complete_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_complete, 
          main = "spearman - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.935, linetype = "dashed")
dev.off()

tiff("k4_centroid_spearman.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_spearman_centroid, 
          main = "spearman - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```


```{r}
clusters_hc_Vi_spearman_average<- cutree(hc_Vi_spearman_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_spearman_average)

cat("\n\n")
clusters_hc_Vi_spearman_single<- cutree(hc_Vi_spearman_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_single)

cat("\n\n")
clusters_hc_Vi_spearman_ward.D2<- cutree(hc_Vi_spearman_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_ward.D2)

cat("\n\n")
clusters_hc_Vi_spearman_complete<- cutree(hc_Vi_spearman_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_complete)

cat("\n\n")
clusters_hc_Vi_spearman_centroid <- cutree(hc_Vi_spearman_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_centroid)
```


```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("connective tissue", "muscle tissue", "nervous tissue", "epithelial tissue")
truth_1 <- factor(rep(lvs_1, times = c(14, 5, 9, 33)), levels = rev(lvs_1))
pred_hc_Vi_spearman_average <- factor(rep(lvs_1, times = c(14, 5, 9, 33)), levels = rev(lvs_1))
pred_hc_Vi_spearman_complete <- factor(rep(lvs_1, times = c(14, 5, 9, 33)), levels = rev(lvs_1))

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_spearman_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("nervous tissue", "muscle tissue", "connective tissue", "epithelial tissue")
truth_3 <- factor(rep(lvs_3, times = c(9, 5, 14, 33)), levels = rev(lvs_3))
pred_hc_Vi_spearman_ward.D2 <- factor(rep(lvs_3, times = c(14, 14, 15, 18)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_spearman_average<- confusionMatrix(table(pred_hc_Vi_spearman_average, truth_1))
cm_hc_Vi_spearman_single<- confusionMatrix(pred_hc_Vi_spearman_single, truth_2)
cm_hc_Vi_spearman_ward.D2<- confusionMatrix(pred_hc_Vi_spearman_ward.D2, truth_3)
cm_hc_Vi_spearman_complete<- confusionMatrix(pred_hc_Vi_spearman_complete, truth_1)
```


```{r}
cm_hc_Vi_spearman_average$overall
cm_hc_Vi_spearman_average$table
cm_hc_Vi_spearman_average$byClass

as.data.frame(t(cm_hc_Vi_spearman_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_spearman_single$overall
cm_hc_Vi_spearman_single$table
cm_hc_Vi_spearman_single$byClass

as.data.frame(t(cm_hc_Vi_spearman_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_spearman_ward.D2$overall
cm_hc_Vi_spearman_ward.D2$table
cm_hc_Vi_spearman_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_spearman_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_spearman_complete$overall
cm_hc_Vi_spearman_complete$table
cm_hc_Vi_spearman_complete$byClass

as.data.frame(t(cm_hc_Vi_spearman_complete$byClass)[5:7,])

```


```{r}
Accuracy_k4<- c(cm_hc_Vi_spearman_average$overall[1], cm_hc_Vi_spearman_single$overall[1], cm_hc_Vi_spearman_ward.D2$overall[1], cm_hc_Vi_spearman_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_spearman_average$overall[2], cm_hc_Vi_spearman_single$overall[2], cm_hc_Vi_spearman_ward.D2$overall[2], cm_hc_Vi_spearman_complete$overall[2])
```


Vemos que ningún método diferencia bien los cuatro grupos realmente. Es cierto que el número de cell types por cluster es correcto para **Complete** y **Average**, pero si nos fijamos veremos que empieza la clasificación anidando de dos en dos, de manera que por un lado está epitelial y por otro connective, muscle y nervous. Luego este ultimo grupo se divide en nervous y en otro grupo que engloba muscle y connective.


```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_average, 
          main = "spearman - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_single, 
          main = "spearman - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_ward.D2, 
          main = "spearman - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_complete, 
          main = "spearman - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_spearman.tiff",width=1720,height=880)
fviz_dend(hc_Vi_spearman_centroid, 
          main = "spearman - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```

```{r}
clusters_hc_Vi_spearman_average<- cutree(hc_Vi_spearman_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_average)

cat("\n\n")
clusters_hc_Vi_spearman_single<- cutree(hc_Vi_spearman_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_single)

cat("\n\n")
clusters_hc_Vi_spearman_ward.D2<- cutree(hc_Vi_spearman_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_ward.D2)

cat("\n\n")
clusters_hc_Vi_spearman_complete<- cutree(hc_Vi_spearman_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_complete)

cat("\n\n")
clusters_hc_Vi_spearman_centroid <- cutree(hc_Vi_spearman_centroid, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_spearman_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
truth_1 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1),  rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 7), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2))

pred_hc_Vi_spearman_average <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1),  rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4),  rep("I", 2)) # distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# no tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_spearman_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 6), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1),  rep("S", 1),rep("O", 6), rep("I", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
truth_3 <- c(rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("W", 6), rep("U", 1), rep("T", 1), rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3), rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 7), rep("L", 1), rep("M", 1))


pred_hc_Vi_spearman_ward.D2<- c(rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("Y", 1), rep("X", 1), rep("V", 4), rep("W", 6), rep("U", 1), rep("T", 1), rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 3), rep("K", 3), rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1)) # distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
truth_4 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2))

pred_hc_Vi_spearman_complete<-  c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2))
# de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_spearman_average<- confusionMatrix(table(pred_hc_Vi_spearman_average, truth_1))
cm_hc_Vi_spearman_single<- confusionMatrix(table(pred_hc_Vi_spearman_single, truth_2))
cm_hc_Vi_spearman_ward.D2<- confusionMatrix(table(pred_hc_Vi_spearman_ward.D2, truth_3))
cm_hc_Vi_spearman_complete<- confusionMatrix(table(pred_hc_Vi_spearman_complete, truth_4))
```


```{r}
cm_hc_Vi_spearman_average$overall
cm_hc_Vi_spearman_average$table
cm_hc_Vi_spearman_average$byClass

as.data.frame(t(cm_hc_Vi_spearman_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_spearman_single$overall
cm_hc_Vi_spearman_single$table
cm_hc_Vi_spearman_single$byClass

as.data.frame(t(cm_hc_Vi_spearman_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_spearman_ward.D2$overall
cm_hc_Vi_spearman_ward.D2$table
cm_hc_Vi_spearman_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_spearman_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_spearman_complete$overall
cm_hc_Vi_spearman_complete$table
cm_hc_Vi_spearman_complete$byClass

as.data.frame(t(cm_hc_Vi_spearman_complete$byClass)[5:7,])

```

```{r}
Accuracy_k25<- c(cm_hc_Vi_spearman_average$overall[1], cm_hc_Vi_spearman_single$overall[1], cm_hc_Vi_spearman_ward.D2$overall[1], cm_hc_Vi_spearman_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_spearman_average$overall[2], cm_hc_Vi_spearman_single$overall[2], cm_hc_Vi_spearman_ward.D2$overall[2], cm_hc_Vi_spearman_complete$overall[2])
```


De nuevo **Average** y **Complete** son los que mejor score tienen,junto con **Ward**. Ward es el mejor situando a urothelial cerca de su verdadero grupo ("O").

Sin embargo, como ninguno hace una correcta clasificación de los cuatro grupos, descartaré esta métrica.



#### 2.4.4.7. Manhattan



```{r}
## 4 clusters
tiff("k4_average_manhattan.tiff",width=1720,height=880)
#par(mar = c(4,1,1,15))
fviz_dend(hc_Vi_manhattan_average, 
          main = "manhattan - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.94, linetype = "dashed")
dev.off()

tiff("k4_single_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_single, 
          main = "manhattan - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.93, linetype = "dashed")
dev.off()

tiff("k4_ward_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_ward.D2, 
          main = "manhattan - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 2.1, linetype = "dashed")
dev.off()

tiff("k4_complete_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_complete, 
          main = "manhattan - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 4, k_colors = c("darkorchid", "dodgerblue", "darkorange2", "chartreuse4")) +
  geom_hline(yintercept = 0.935, linetype = "dashed")
dev.off()

tiff("k4_centroid_manhattan.tiff",width=1720,height=880)
# For the method Centroid, it is impossible to produce a clear division in 4
fviz_dend(hc_Vi_manhattan_centroid, 
          main = "manhattan - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE)
dev.off()
```


```{r}
clusters_hc_Vi_manhattan_average<- cutree(hc_Vi_manhattan_average, k = 4, order_clusters_as_data = FALSE) # the last indication allows to match clusters order with the dendogram
table(clusters_hc_Vi_manhattan_average)

cat("\n\n")
clusters_hc_Vi_manhattan_single<- cutree(hc_Vi_manhattan_single, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_single)

cat("\n\n")
clusters_hc_Vi_manhattan_ward.D2<- cutree(hc_Vi_manhattan_ward.D2, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_ward.D2)

cat("\n\n")
clusters_hc_Vi_manhattan_complete<- cutree(hc_Vi_manhattan_complete, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_complete)

cat("\n\n")
clusters_hc_Vi_manhattan_centroid <- cutree(hc_Vi_manhattan_centroid, k = 4, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_centroid)
```


```{r}
## Build the confusion matrix object

# Average & Complete
lvs_1 <- c("epithelial tissue", "connective tissue", "muscle tissue", "nervous tissue")
truth_1 <- factor(rep(lvs_1, times = c(33, 14, 5, 9)), levels = rev(lvs_1))
pred_hc_Vi_manhattan_average <- factor(rep(lvs_1, times = c(18, 15, 19, 9)), levels = rev(lvs_1)) # este método es muchísimo peor con esta distancia que con las tres anteriores
pred_hc_Vi_manhattan_complete <- factor(rep(lvs_1, times = c(18, 15, 19, 9)), levels = rev(lvs_1)) # este método es muchísimo peor con esta distancia que con las tres anteriores

# Single
lvs_2 <- c("connective tissue", "epithelial tissue", "muscle tissue", "nervous tissue")
truth_2 <- factor(rep(lvs_2, times = c(14, 33, 5, 9)), levels = rev(lvs_2))
pred_hc_Vi_manhattan_single <- factor(rep(lvs_2, times = c(29, 18, 5, 9)), levels = rev(lvs_2))

# Ward
lvs_3 <- c("epithelial tissue", "nervous tissue", "muscle tissue", "connective tissue")
truth_3 <- factor(rep(lvs_3, times = c(33, 9, 5, 14)), levels = rev(lvs_3))
pred_hc_Vi_manhattan_ward.D2 <- factor(rep(lvs_3, times = c(15, 18, 14, 14)), levels = rev(lvs_3)) # divide en dos grupos las epiteliales, y junta en el mismo grupo las neuronales y del musculo

cm_hc_Vi_manhattan_average<- confusionMatrix(table(pred_hc_Vi_manhattan_average, truth_1))
cm_hc_Vi_manhattan_single<- confusionMatrix(pred_hc_Vi_manhattan_single, truth_2)
cm_hc_Vi_manhattan_ward.D2<- confusionMatrix(pred_hc_Vi_manhattan_ward.D2, truth_3)
cm_hc_Vi_manhattan_complete<- confusionMatrix(pred_hc_Vi_manhattan_complete, truth_1)
```


```{r}
cm_hc_Vi_manhattan_average$overall
cm_hc_Vi_manhattan_average$table
cm_hc_Vi_manhattan_average$byClass

as.data.frame(t(cm_hc_Vi_manhattan_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_manhattan_single$overall
cm_hc_Vi_manhattan_single$table
cm_hc_Vi_manhattan_single$byClass

as.data.frame(t(cm_hc_Vi_manhattan_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_manhattan_ward.D2$overall
cm_hc_Vi_manhattan_ward.D2$table
cm_hc_Vi_manhattan_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_manhattan_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_manhattan_complete$overall
cm_hc_Vi_manhattan_complete$table
cm_hc_Vi_manhattan_complete$byClass

as.data.frame(t(cm_hc_Vi_manhattan_complete$byClass)[5:7,])

```



```{r}
Accuracy_k4<- c(cm_hc_Vi_manhattan_average$overall[1], cm_hc_Vi_manhattan_single$overall[1], cm_hc_Vi_manhattan_ward.D2$overall[1], cm_hc_Vi_manhattan_complete$overall[1])

Kappa_k4<- c(cm_hc_Vi_manhattan_average$overall[2], cm_hc_Vi_manhattan_single$overall[2], cm_hc_Vi_manhattan_ward.D2$overall[2], cm_hc_Vi_manhattan_complete$overall[2])
```


Ninguno de los métodos hace una correcta distinción de los cuatro grupos. Esto nos da una pista de que esta distancia no va a ser la más acertada.


```{r}
## 24 o 25 clusters: pancreatic_endocrine_cells could belong either group "I" or "J". We do not know which subtype is (alpha, beta or delta). Let's try which way it fits better, included in "I" group or forming another separate one, "J". Cuando no cuadre una división en 25, lo dividiré en 24 el dendograma.

palette_Vi_24 <- distinctColorPalette(24)
palette_Vi_25 <- distinctColorPalette(25)

tiff("k25_average_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_average, 
          main = "manhattan - Average", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          hang=-1,
          k = 25, k_colors = palette_Vi_25) + 
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_single_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_single, 
          main = "manhattan - Single", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 24, k_colors = palette_Vi_24) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

tiff("k25_ward_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_ward.D2, 
          main = "manhattan - Ward", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.6, linetype = "dashed")
dev.off()

tiff("k25_complete_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_complete, 
          main = "manhattan - Complete", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE, 
          k = 25, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.52, linetype = "dashed")
dev.off()

# For the method Centroid, it is impossible to produce a clear division in 4
tiff("k25_centroid_manhattan.tiff",width=1720,height=880)
fviz_dend(hc_Vi_manhattan_centroid, 
          main = "manhattan - Centroid", 
          xlab = "",  ylab = "", 
          cex = 1.5, 
          lwd = 1,
          horiz = TRUE) 
dev.off()
```

```{r}
clusters_hc_Vi_manhattan_average<- cutree(hc_Vi_manhattan_average, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_average)

cat("\n\n")
clusters_hc_Vi_manhattan_single<- cutree(hc_Vi_manhattan_single, k = 24, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_single)

cat("\n\n")
clusters_hc_Vi_manhattan_ward.D2<- cutree(hc_Vi_manhattan_ward.D2, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_ward.D2)

cat("\n\n")
clusters_hc_Vi_manhattan_complete<- cutree(hc_Vi_manhattan_complete, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_complete)

cat("\n\n")
clusters_hc_Vi_manhattan_centroid <- cutree(hc_Vi_manhattan_centroid, k = 25, order_clusters_as_data = FALSE) 
table(clusters_hc_Vi_manhattan_centroid)
```


```{r}
## Confusion matrix

# Average, 25 clusters
# There is no alternative for k=24.
truth_1 <- c(rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("L", 1), rep("M", 1), rep("E", 3), rep("C",3 ), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA",2 ), rep("BB", 1))

pred_hc_Vi_manhattan_average <- c(rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 6), rep("J", 1), rep("L", 1), rep("M", 1), rep("E", 3), rep("C",3 ), rep("B", 2), rep("D", 1), rep("K", 4),  rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA",2 ), rep("BB", 1)) # distingue casi perfectamente K de I, solo que al cell type dudoso de ser I o J lo incluye dentro de K; urothelial esta aparte, formando él solo un unico cluster mal identificado como "J"


# Single, 24 clusters
# no tiene sentido una división de 25, ya que segun la linea que corta recto el dendograma solo hay la posibilidad de dividir en 24 o en 26 grupos el árbol
truth_2 <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("I", 3), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1),  rep("S", 1), rep("O", 7), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_manhattan_single <- c(rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 6), rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1),  rep("S", 1), rep("O", 6), rep("I", 1),rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1)) # junta K e I en el mismo cluster, recordemos que aqui no existe "J" porque el dendograma no parece soportar una división de 25 clusters; urothelial esta aparte, formando él solo un unico cluster, mal identificado como "I", cuando en realidad es "O"


# Ward, 25 clusters
# There is no posibility of k=24
truth_3 <- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 2), rep("J", 1), rep("K", 3), rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 7), rep("L", 1), rep("M", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("X", 1), rep("Y", 1), rep("V", 4), rep("W", 6), rep("U", 1), rep("T", 1))

pred_hc_Vi_manhattan_ward.D2<- c(rep("B", 2), rep("D", 1), rep("C", 3), rep("E", 3), rep("I", 3), rep("K", 3), rep("S", 1), rep("Q", 1), rep("P", 7), rep("O", 6),  rep("J", 1), rep("L", 1), rep("M", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1), rep("HH", 4), rep("FF", 1), rep("X", 1), rep("Y", 1), rep("V", 4), rep("W", 6), rep("U", 1), rep("T", 1)) # distingue K de I, pero no distingue "J" sino que lo incluye dentro de "I"; sigue sin juntar urothelial con su grupo, se le ha identificado mal como "J", he de decir que es el metodo que más relaciona urothelial con su grupo (estan muy proximos entre si)


# Complete, 25 clusters
# si no pongo nada, es que no hay posibilidad de 24
truth_4 <- c(rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O", 7), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 3), rep("J", 1), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))

pred_hc_Vi_manhattan_complete<-  c(rep("L", 1), rep("M", 1), rep("P", 7), rep("Q", 1), rep("S", 1), rep("O",6), rep("J", 1), rep("E", 3), rep("C", 3), rep("B", 2), rep("D", 1), rep("K", 4), rep("I", 2), rep("V", 4), rep("W", 6), rep("X", 1), rep("Y", 1), rep("U", 1), rep("T", 1), rep("HH", 4), rep("FF", 1), rep("CC", 2), rep("DD", 4), rep("AA", 2), rep("BB", 1))# de nuevo, no distingue el grupo "J", sino que lo incluye dentro de "K"; sigue sin incluir urothelial en "O", lo malinterpreta como "J"


cm_hc_Vi_manhattan_average<- confusionMatrix(table(pred_hc_Vi_manhattan_average, truth_1))
cm_hc_Vi_manhattan_single<- confusionMatrix(table(pred_hc_Vi_manhattan_single, truth_2))
cm_hc_Vi_manhattan_ward.D2<- confusionMatrix(table(pred_hc_Vi_manhattan_ward.D2, truth_3))
cm_hc_Vi_manhattan_complete<- confusionMatrix(table(pred_hc_Vi_manhattan_complete, truth_4))
```


```{r}
cm_hc_Vi_manhattan_average$overall
cm_hc_Vi_manhattan_average$table
cm_hc_Vi_manhattan_average$byClass

as.data.frame(t(cm_hc_Vi_manhattan_average$byClass)[5:7,])

```


```{r}
cm_hc_Vi_manhattan_single$overall
cm_hc_Vi_manhattan_single$table
cm_hc_Vi_manhattan_single$byClass

as.data.frame(t(cm_hc_Vi_manhattan_single$byClass)[5:7,])

```


```{r}
cm_hc_Vi_manhattan_ward.D2$overall
cm_hc_Vi_manhattan_ward.D2$table
cm_hc_Vi_manhattan_ward.D2$byClass

as.data.frame(t(cm_hc_Vi_manhattan_ward.D2$byClass)[5:7,])

```


```{r}
cm_hc_Vi_manhattan_complete$overall
cm_hc_Vi_manhattan_complete$table
cm_hc_Vi_manhattan_complete$byClass

as.data.frame(t(cm_hc_Vi_manhattan_complete$byClass)[5:7,])

```

```{r}
Accuracy_k25<- c(cm_hc_Vi_manhattan_average$overall[1], cm_hc_Vi_manhattan_single$overall[1], cm_hc_Vi_manhattan_ward.D2$overall[1], cm_hc_Vi_manhattan_complete$overall[1])

Kappa_k25<- c(cm_hc_Vi_manhattan_average$overall[2], cm_hc_Vi_manhattan_single$overall[2], cm_hc_Vi_manhattan_ward.D2$overall[2], cm_hc_Vi_manhattan_complete$overall[2])
```


### 2.4.4. Accuracy and Kappa


```{r}
hclust <- c("Average", "Single", "Ward", "Complete", "Average", "Single", "Ward", "Complete", "Average", "Single", "Ward", "Complete", "Average", "Single", "Ward", "Complete", "Average", "Single", "Ward", "Complete", "Average", "Single", "Ward", "Complete", "Average", "Single", "Ward", "Complete")

# "Jaccard", "Dice", "Cosine", "Euclidean", "Pearson", "Spearman", "Manhattan"

df_4 <- data.frame(hclust, Accuracy_k4, Kappa_k4)
colnames(df_4)<- c("hclust", "Accuracy", "Kappa")

df_25 <- data.frame(hclust, Accuracy_k25, Kappa_k25)
colnames(df_25)<- c("hclust", "Accuracy", "Kappa")
```


```{r}
kbl(df_4) %>%
kable_paper("striped", full_width = F) %>%
  pack_rows("Jaccard", 1, 4) %>%
  pack_rows("Dice", 5, 8) %>%
  pack_rows("Ochiai", 9, 12) %>%
  pack_rows("Euclidean", 13, 16) %>%
  pack_rows("Pearson", 17, 20) %>%
  pack_rows("Spearman", 21, 24) %>%
   pack_rows("Spearman", 25, 28)
```


```{r}
kbl(df_25) %>%
kable_paper("striped", full_width = F) %>%
  pack_rows("Jaccard", 1, 4) %>%
  pack_rows("Dice", 5, 8) %>%
  pack_rows("Ochiai", 9, 12) %>%
  pack_rows("Euclidean", 13, 16) %>%
  pack_rows("Pearson", 17, 20) %>%
  pack_rows("Spearman", 21, 24) %>%
  pack_rows("Spearman", 25, 28)
```



### 2.4.5. Internal validation clustering



```{r}
## Within-cluster sum of squares
# shows how compact the clusters are for different k values.
#It assumes that we want clusters to be as compact (high cohesion, high separation) as possible.
fviz_nbclust(df_VH, kmeans, method = "wss", k.max = 25) + theme_minimal() + ggtitle("the Elbow Method")

# The Silhouette Plot
# It measures cohesion and separation based on the following indicators
fviz_nbclust(df_VH, kmeans, method = "silhouette", k.max = 25) + theme_minimal() + ggtitle("The Silhouette Plot")
```



Para k=4:

- El método Complete con las distancias Jaccard, Dice y Cosine es el unico que distingue perfectamente los cuatro grupos.
- Descarto por completo el método centroid.
- Los métodos Average y Complete tienen una accuracy y kappa de 1 para todas las distancias, excepto para Euclidean y Manhattan.
- 

Para k=25:

- Ningún método clasifica los tipos celulares pertenecientes a los grupos O, K, J (en caso de existir) e I a la perfección.
- El valor alcanzado más alto de accuracy y kappa es 0.97. Los métodos menos buenos según estas dos scores son Pearson-Average con 0.96 y todas las distancias con Single (0.93).
- Los scores precision, recall y F1 son exactamente iguales para todos los métodos/distancias.


Por lo tanto, escogeré cualquiera de los tres dendogramas Complete - jaccard, dice o cosine. He elegido **Dice-complete** porque tienen las ramas más cortas los grupos. 

"darkorchid", "dodgerblue", "darkorange2", "chartreuse4"





# 3. Compilation of functional and morphological characteristics of cell types in Cell Ontology



## 3.1. Generate data


```{r}
# ---- NOTES ----

# Some considerations about Cell Ontology

###  There is no ID for "undifferentiated cells". They include stem cells, transit-amplifying cells (TA), and progenitor/precursors cells from the intestines. In any case, Vickarious does not include it in their classification either.
### There is no ID for "mixed immune cells" and "mixed cell types". In any case, Vickarious does not include it in their classification either.
###  There is only one ID for late and early spermatids. In any case, Vickarious does not include it in their classification either.
### Vickarious does not distinguish between proximal and distal enterocytes (in Vickarious I double the term). This is the ID in case I just want the general term: 

##### "CL:0000584" # enterocyte
                   # large and small intestines


# I remove the following cell types because they are not included in the Vickarious classification:
 
#### "CL:0002341", # basal prostatic cells
                   # prostate
#### "CL:1000447", # basal squamous epithelial cells: stem cells in the basal layer of stratified squamous epithelia
                   # esophagus
#### "CL:0002187", # basal keratinocytes: stem cells found in the basal layer of the epidermis in skin
                   # skin
#### "CL:0002453", # oligodendrocyte precursor cells
                   # brain
#### "CL:0000020", # spermatogonia
                   # testis 
#### "CL:0000017", # spermatocytes
                   # testis
#### "CL:0000018", # spermatids (there is no ID for late and early spermatids)
                   # testis 
#### "CL:0000525", # syncytiotrophoblasts
                   # placenta 
#### "CL:0000523", # cytotrophoblasts
                   # placenta 
#### "CL:0008036"  # extravillous trophoblasts
                   # placenta
#### "CL:3000001", # hofbauer cells (placental macrophages)
                   # placenta 
#### "CL:0005006", # ionocytes
                   # bronchus 
#### "CL:0002255", # endometrial stromal cells
                   # endometrium  
                   # The endometrial stromal layer comprises uterine fibroblasts and a mix of immune cells.


# -----------------




ct<- c(
  "CL:0000136", # adipocytes
                # adipose tissue, breast
  "CL:0000235", # macrophages
                # adipose tissue, bone marrow, breast, endometrium, esophagus, kidney, lung, ovary, pancreas,                                                           pbmc, prostate, skeletal muscle, spleen, stomach, testis
  "CL:0000091", # kupffer cells
                # liver 
  "CL:0000576", # monocytes
                # pancreas, pbmc 
  "CL:0000084", # t-cells
                # adipose tissue, bone marrow, breast, colon, endometrium, esophagus, kidney, liver, lung, lymph node,                                                  ovary, pbmc, prostate, skeletal muscle, skin, spleen, stomach 
  "CL:0000236", # b-cells
                # adipose tissue, bone marrow, breast, colon, kidney, liver, lymph node, pbmc, spleen, stomach
  "CL:0000094", # granulocytes 
                # colon, lung 
  "CL:0000232", # erythroid cells
                # bone marrow, liver 
  "CL:0000623", # nk-cells
                # pbmc 
  "CL:0001056", # dendritic cells
                # adipose tissue, breast, pbmc 
  "CL:0000453", # langerhans cells
                # skin 
  "CL:0000786", # plasma cells
                # adipose tissue, bone marrow, esophagus, spleen, stomach 
  "CL:0008024", # pancreatic endocrine cells
                # pancreas 
  "CL:0000178", # leydig cells
                # testis 
  "CL:0000164", # enteroendocrine cells
                # colon, rectum 
  "CL:0000503", # theca cells
                # ovary 
  "CL:0002064", # exocrine glandular cells
                # pancreas 
  "CL:0002313", # prostatic glandular cells
                # prostate 
  "CL:0002179", # gastric mucus-secreting cells
                # stomach 
  "CL:0000510", # paneth cells
                # colon, rectum, small intestine 
  "CL:0000158", # club cells
                # bronchus, lung 
  "CL:0002332", # respiratory ciliated cells
                # bronchus, lung 
  "CL:0019031", # intestinal goblet cells
                # colon, rectum, small intestine 
  "CL:1001586", # breast glandular cells
                # breast 
  "CL:0002324", # breast myoepithelial cells
                # breast 
  "CL:0002633", # basal respiratory cells
                # bronchus 
  "CL:0002656", # glandular and luminal cells
                # endometrium 
  "CL:0000115", # endothelial cells
                # breast, endometrium, esophagus, eye, heart muscle, liver, lung, ovary, pancreas, placenta, prostate,                                skeletal muscle, skin, testis 
  "CL:0000636", # muller glia cells
                # eye 
  "CL:0000128", # oligodendrocytes
                # brain 
  "CL:0000127", # astrocytes
                # brain
  "CL:0000129", # microglial cells
                # brain 
  "CL:0000057", # fibroblasts
                # adipose tissue, breast, esophagus, heart muscle, lung, ovary, placenta, prostate, skeletal muscle, skin,                                              stomach 
  "CL:0000632", # hepatic stellate cells
                # liver 
  "CL:0002481", # peritubular cells
                # testis 
  "CL:0000746", # cardiomyocytes
                # heart muscle 
  "CL:0000192", # smooth muscle cells
                # adipose tissue, breast, bronchus, endometrium, esophagus, heart muscle, ovary, pancreas, prostate,                                  skeletal muscle, skin 
  "CL:0008002", # skeletal myocytes
                # skeletal muscle 
  "CL:0000745", # horizontal cells
                # eye 
  "CL:0000573", # cone photoreceptor cells
                # eye 
  "CL:0000604", # rod photoreceptor cells 
                # eye 
  "CL:0000103", # bipolar cells
                # eye 
  "CL:0008030", # excitatory neurons
                # brain 
  "CL:0008029", # inhibitory neurons  
                # brain 
  "CL:0000148", # melanocytes 
                # skin 
  "CL:0000240", # squamous epithelial cells 
                # esophagus 
  "CL:0000312", # suprabasal keratinocytes
                # skin 
  "CL:0002079", # pancreatic ductal cells
                # pancreas
  "CL:1001225", # collecting duct cells
                # kidney 
  "CL:0000731", # urothelial cells
                # prostate 
  "CL:0000182", # hepatocytes
                # liver 
  "CL:1000488", # cholangiocytes
                # liver 
  "CL:0002063", # alveolar cells type 2
                # lung 
  "CL:0002062", # alveolar cells type 1
                # lung 
  "CL:0002306", # proximal tubular cells
                # kidney 
  "CL:0002305", # distal tubular cells
                # kidney 
  "CL:0000216", # sertoli cells
                # testis
  "CL:1001591", # endometrial ciliated cells
                # endometrium
  "CL:1000334", # proximal enterocytes
                # intestine (small intestine)
  "CL:0002071", # distal enterocytes
                # colon, rectum (large intestine)
  "CL:0000501"  # granulosa cells
                # ovary 
  )

```


```{r}
# Link to Cell Ontology - OBO Foundary products: https://obofoundry.org/ontology/cl.html
file <- "https://raw.githubusercontent.com/obophenotype/cell-ontology/master/cl-basic.obo"
data <- get_OBO(file)
```


```{r}
# Create list with all parent terms (not repeated)
# WARNING: since it includes node term, I will later remove the last element of the list which corresponds to the node term (the cell type name)

ParentTerms_ID<- c()
ParentTerms_names<- c()

for (i in ct) {
  
  A<- get_ancestors(data, i)
  B<- head(A, -1) # remove last element of the list = node term
  ParentTerms_ID<- c(ParentTerms_ID, B)
  
  D<- data$name[get_ancestors(data, i)]
  E<- head(D, -1) # remove last element of the list = node term
  ParentTerms_names<- c(ParentTerms_names, E)
}

ParentTerms_ID_unique<- unique(ParentTerms_ID)
ParentTerms_names_unique<- unique(ParentTerms_names)

# Check for missing data
any(is.na(ParentTerms_ID))
any(is.na(ParentTerms_names))
```

```{r}
A<- matrix(0, length(ct), length(ParentTerms_ID_unique))
df_CellOntoloy<- as.data.frame(A)
colnames(df_CellOntoloy)<- ParentTerms_names_unique
rownames(df_CellOntoloy) <- data$name[ct]
```


```{r}
for (i in ct) {
   A<- c()
   A<- data$name[get_ancestors(data, i)]
   B<- head(A, -1)
   
   for (j in B) {
     
     df_CellOntoloy[data$name[i], j]<-1
   }
}
```



**Feature selection**:

From Clustering with optimized weights for Gower’s metric, By Jeroen van den Hoven:


*We first look at variables that we want to remove before we start to look into specific features to keep.The variables that are removed in this way fulfill at least one of the following criteria:*


- ***1. Variables that are not user-specific*** *; If they do not describe the behavior of the user, then we cannot use them to distinguish users with.*

Since all features are parent terms, all of them are valid for describing the cell types.

- ***2. Categorical variables with too many levels*** *are removed; The only exception to this is user-id, which we keep until we perform the clustering. Variables with too many levels are those with more levels than 30% of the number of instances.*

I only have two levels, 0 and 1.

- ***3. Variables with more than 90% NA’s*** *are removed immediately; Variables with more than 40% NA’s are inspected more closely before we make a decision to remove them.

I have no NA's.

- ***4. Variables that have only one possible value*** *, excluding NA, are removed;

This has to be done.

- ***5. Variables which are a duplicate of another variable*** *; Variables which hold similar information as others (such as mean time online and total time online) also fall into this category. We remove all but one of these variables for each set of duplicates.

This has to be done.



```{r}
## --- EXECUTE JUST ONCE ---

which(apply(df_CellOntoloy, 2, function(x) length(unique(x))) == 1) 
# Output: "cell", "native cell" 
# Additionally, I'll also remove "animal cell", "eukaryotic cell"
```


```{r}
del<- c("cell", "native cell", "animal cell", "eukaryotic cell")
df_CellOntoloy <-select(df_CellOntoloy, -del)
```



```{r}
# Change rownames for the shake of comparing the dendogram with the others. 
# This step has to be done after filling the matrix
rownames(df_CellOntoloy) <- names(terms)
```


## 3.2. Exploratory Data Analysis


```{r}
animal_cell_subdivisions<- c("bladder cell", "bone cellClass", "cardiocyte", "collar cell", "connective tissue cell", "cystoblast", "embryonic cell (metazoa)", "epithelial cell", "extraembryonic cell", "germ line stem cell (sensu Vertebrata)", "hematopoietic cell", "hemocyte (sensu Arthropoda)", "kidney cell", "lower urinary tract cell", "micropylar cell", "muscle cell", "myofibroblast cell", "neural cell", "neuroblast (sensu Vertebrata)", "oocyte", "phagocyte (sensu Vertebrata)", "pigment cell (sensu Vertebrata)", "ureteral cell", "urethra cell")

nclusters<- c()

for (i in animal_cell_subdivisions) {
  
  if (i %in% ParentTerms_names_unique) {
    nclusters<- c(nclusters, i)
  }
}

cat("Number of clusters accoring to Cell Ontology:", length(nclusters))
```


## 3.3. Internal validation clustering



```{r}
# https://www.r-bloggers.com/2019/01/10-tips-for-choosing-the-optimal-number-of-clusters/

set.seed(31)
# Within-cluster sum of squares
fviz_nbclust(df_CellOntoloy, kmeans, method = "wss", k.max = 40) + theme_minimal() + ggtitle("the Elbow Method")

## 3, 8, 11...

# The Silhouette Plot
fviz_nbclust(df_CellOntoloy, kmeans, method = "silhouette", k.max = 40) + theme_minimal() + ggtitle("The Silhouette Plot")

## 23, 18, 15
```



## 3.4. Hierarchical clustering


```{r}
metrics_co<-  c("manhattan", "spearman", "pearson", "euclidean", "manhattan", "5", "1", "7") #5=Sørensen-Dice, 1=Jaccard, 7=Cosine
methods_co<- c("ward.D2", "single", "complete", "average", "centroid")

ID_corr_co<- c()
corr_list_co<- c()

for (i in metrics_co) {
  
  if (i == "5" | i == "1" | i == "7") {
    
    dist<- dist.binary(df_CellOntoloy, method = i)
    
    # Save it into a variable
    name_dist<- paste("dist_co", i, sep="_") 
    assign(name_dist, dist, envir = .GlobalEnv)
  
  } else {
   
    dist<- get_dist(df_CellOntoloy, method = i) 
   
    # Save it into a variable
    name_dist<- paste("dist_co", i, sep="_", collapse=NULL) 
    assign(name_dist, dist, envir = .GlobalEnv)
   
    }
  
  for(j in methods_co) {
    
    # Cluster data in a hierarchical tree according to distance matrix values
    hc <- hclust(d = dist, method = j)
    
    # Save it into a variable
    name_hc<- paste("hc_co", i, j, sep="_", collapse=NULL) 
    assign(name_hc, hc, envir = .GlobalEnv)
    
    # Create dendogram
    dend<- as.dendrogram(hc)
    
    # Save it into a variable
    name_dend<- paste("dend_co", i, j, sep="_", collapse=NULL) 
    assign(name_dend, dend, envir = .GlobalEnv)

    # Calculate Cophentic distance matrix
    coph.dist<- cophenetic(hc)
    
    # Save it into a variable
    name_coph.dist<- paste("coph_dist_co", i, j, sep="_", collapse=NULL) 
    assign(name_coph.dist, coph.dist, envir = .GlobalEnv)
    
    # Correlation between cophenetic distance and the original distance
    corr<- cor(dist, coph.dist)
    
    # Save it into a variable
    name_corr<- paste("corr_coph_co", i, j, sep="_", collapse=NULL) 
    assign(name_corr, corr, envir = .GlobalEnv)
    
     # Add correlations between cophenetic distance and the original distance to a list
    corr_list_co<-c(corr_list_co, corr)
    
    # Save the name of the variables into a vector
    ID_corr_co<- c(ID_corr_co, name_corr)
  }
} 
```


### 3.4.1. Distance matrix

The classification of observations into groups requires some methods for computing the distance or the (dis)similarity between each pair of observations. The result of this computation is known as a dissimilarity or distance matrix.


```{r}
# Visualize all distance matrices ("euclidean", "Dice/Sorensen", "Jaccard", "Ochiai")

dm_pearson<- fviz_dist(dist_co_pearson, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Pearson")


dm_spearman<- fviz_dist(dist_co_spearman, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Spearman")


dm_euclidean<- fviz_dist(dist_co_euclidean, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Euclidean")


dm_dice<- fviz_dist(dist_co_1, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Dice")


dm_jaccard<- fviz_dist(dist_co_5, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Jaccard dissimilarity index")


figure<- ggarrange(dm_pearson, dm_spearman, dm_euclidean, dm_dice, dm_jaccard,
          ncol = 2, nrow = 3)


annotate_figure(figure,
                top = text_grob("", face = "bold", size = 1),
                bottom = text_grob("\nData source: Karlsson et al. (2021)", hjust = 1, x = 1, face = "italic", size = 10),
                fig.lab = "", fig.lab.face = "bold",  fig.lab.size=1
                )
```



```{r}
# Calculate melted distance matrix
melted_dm1<- melt(as.matrix(dist_co_euclidean))
melted_dm2<- melt(as.matrix(dist_co_1))
melted_dm3<- melt(as.matrix(dist_co_5))
melted_dm4<- melt(as.matrix(dist_co_7))
melted_dm5<- melt(as.matrix(dist_co_pearson))
melted_dm6<- melt(as.matrix(dist_co_spearman))
```


```{r}
# For example
#tiff("Jaccard_co.tiff",width=3840,height=2160)

fviz_dist(dist_co_1, show_labels = FALSE) + 
  theme(axis.text.x=element_text(colour="grey20",size=40, angle = 90, hjust = 1, vjust=0.5),
        axis.text.y=element_text(colour="grey20", size=40, hjust=1)) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  theme(legend.position="none")

#dev.off()
```



### 3.4.2. Cophenetic correlation coefficient (Rohlf, 1962)


```{r}
# Employ cophentic correlation to identify which of the linkage methods mentioned above produces the dendrogram with the highest similarity to the underlying distance matrix.

df_corr_co <- data.frame(ID_corr_co, corr_list_co)

# The numbers are indeed of type character. I need to convert them to numeric
df_corr_co<- transform(df_corr_co,corr_list_co = as.numeric(corr_list_co)) 

# Order from greater to smaller CoCC value
df_corr_co<- arrange(df_corr_co, desc(corr_list_co)) 


## According to Rohlf (1988):
# very good = >0.9
# good = 0.8 - 0.9
# reasonably good = 0.7 - 0.8

Target<- c()

for (i in seq_along(corr_list_co)){
  
  if (df_corr_co$corr_list_co[i] > 0.9) {
    Target<- c(Target, "Very good")
  } 
  
  if (df_corr_co$corr_list_co[i] > 0.8 & df_corr_co$corr_list_co[i] <= 0.9) {
    Target<- c(Target, "Good")
  } 
  
  if (df_corr_co$corr_list_co[i] > 0.7 & df_corr_co$corr_list_co[i] <= 0.8) {
    Target<- c(Target, "Reasonably good")
  } 
  
  if (df_corr_co$corr_list_co[i] <= 0.7) {
    Target<- c(Target, "Not good")
  }
}

# Add target column
df_corr_co<- cbind(df_corr_co, Target)
df_corr_co<- transform(df_corr_co, Target=as.factor(Target))

# See default levels order:
levels(df_corr_co$Target) 
# "Good", "Not good", "Reasonably good", "Very good" 

# Specify the factor levels in the order I want
df_corr_co$Target <- factor(df_corr_co$Target, levels = c("Very good", "Good", "Reasonably good", "Not good"))
```


```{r}
# Visualize best coph corr

ggplot(df_corr_co, aes(x=reorder(ID_corr_co, -corr_list_co), y=corr_list_co, fill=Target)) + 
  geom_bar(stat="identity", size=1) + 
  scale_fill_manual(values=c("deeppink", "deeppink4", "brown", "gray")) +
  theme(axis.text.x=element_text(colour="grey20",size=15),
        axis.text.y=element_text(colour="grey20", hjust=1,vjust=0.8,size=10),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Hierarchical tree\n\n", y = "\n\nCophenetic correlation coefficient\n\n") + 
  
  theme(legend.position= "bottom",
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  guides(fill=guide_legend(title="Rohlf (1988)",keywidth = 2, keyheight = 1, title.position = "left", title.hjust = -0.1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  coord_flip()
```



### 3.4.3. Index of Agreement


According to Willmot the index of agreement “is not a measure of correlation or association in the formal sense, but rather a measure of the degree to which a model’s predictions are error free.”. An index of agreement of 1 indicates perfect agreement, whilst a value of 0 indicates complete disagreement.


```{r}
# A value of 1 indicates a perfect match, and 0 indicates no agreement at all



# Jaccard

IoA_jaccard_complete_co<- d(as.matrix(coph_dist_co_1_complete), as.matrix(dist_co_1), na.rm = FALSE)
df_IoA_coz<- data.frame(IoA_jaccard_complete_co)

IoA_jaccard_ward.D2_co<- d(as.matrix(coph_dist_co_1_ward.D2), as.matrix(dist_co_1), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_jaccard_ward.D2_co)

IoA_jaccard_single_co<- d(as.matrix(coph_dist_co_1_single), as.matrix(dist_co_1), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_jaccard_single_co)

IoA_jaccard_average_co<- d(as.matrix(coph_dist_co_1_average), as.matrix(dist_co_1), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_jaccard_average_co)
                                              
IoA_jaccard_centroid_co<- d(as.matrix(coph_dist_co_1_centroid), as.matrix(dist_co_1), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_jaccard_centroid_co)


# Dice

IoA_dice_complete_co<- d(as.matrix(coph_dist_co_5_complete), as.matrix(dist_co_5), na.rm = FALSE)
df_IoA_coz<- data.frame(IoA_dice_complete_co)

IoA_dice_ward.D2_co<- d(as.matrix(coph_dist_co_5_ward.D2), as.matrix(dist_co_5), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_dice_ward.D2_co)

IoA_dice_single_co<- d(as.matrix(coph_dist_co_5_single), as.matrix(dist_co_5), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_dice_single_co)

IoA_dice_average_co<- d(as.matrix(coph_dist_co_5_average), as.matrix(dist_co_5), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_dice_average_co)
                                              
IoA_dice_centroid_co<- d(as.matrix(coph_dist_co_5_centroid), as.matrix(dist_co_5), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_dice_centroid_co)


# Cosine

IoA_cosine_complete_co<- d(as.matrix(coph_dist_co_7_complete), as.matrix(dist_co_7), na.rm = FALSE)
df_IoA_coz<- data.frame(IoA_cosine_complete_co)

IoA_cosine_ward.D2_co<- d(as.matrix(coph_dist_co_7_ward.D2), as.matrix(dist_co_7), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_cosine_ward.D2_co)

IoA_cosine_single_co<- d(as.matrix(coph_dist_co_7_single), as.matrix(dist_co_7), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_cosine_single_co)

IoA_cosine_average_co<- d(as.matrix(coph_dist_co_7_average), as.matrix(dist_co_7), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_cosine_average_co)
                                              
IoA_cosine_centroid_co<- d(as.matrix(coph_dist_co_7_centroid), as.matrix(dist_co_7), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_cosine_centroid_co)


# Euclidean

IoA_euclidean_complete_co<- d(as.matrix(coph_dist_co_euclidean_complete), as.matrix(dist_co_euclidean), na.rm = FALSE)
df_IoA_coz<- data.frame(IoA_euclidean_complete_co)

IoA_euclidean_ward.D2_co<- d(as.matrix(coph_dist_co_euclidean_ward.D2), as.matrix(dist_co_euclidean), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_euclidean_ward.D2_co)

IoA_euclidean_single_co<- d(as.matrix(coph_dist_co_euclidean_single), as.matrix(dist_co_euclidean), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_euclidean_single_co)

IoA_euclidean_average_co<- d(as.matrix(coph_dist_co_euclidean_average), as.matrix(dist_co_euclidean), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_euclidean_average_co)
                                              
IoA_euclidean_centroid_co<- d(as.matrix(coph_dist_co_euclidean_centroid), as.matrix(dist_co_euclidean), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_euclidean_centroid_co)


## Spearman

IoA_spearman_complete_co<- d(as.matrix(coph_dist_co_spearman_complete), as.matrix(dist_co_spearman), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_spearman_complete_co)

IoA_spearman_ward.D2_co<- d(as.matrix(coph_dist_co_spearman_ward.D2), as.matrix(dist_co_spearman), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_spearman_ward.D2_co)

IoA_spearman_single_co<- d(as.matrix(coph_dist_co_spearman_single), as.matrix(dist_co_spearman), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_spearman_single_co)

IoA_spearman_average_co<- d(as.matrix(coph_dist_co_spearman_average), as.matrix(dist_co_spearman), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_spearman_average_co)

IoA_spearman_centroid_co<- d(as.matrix(coph_dist_co_spearman_centroid), as.matrix(dist_co_spearman), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_spearman_centroid_co)


## Pearson
IoA_pearson_complete_co<- d(as.matrix(coph_dist_co_pearson_complete), as.matrix(dist_co_pearson), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_pearson_complete_co)

IoA_pearson_ward.D2_co<- d(as.matrix(coph_dist_co_pearson_ward.D2), as.matrix(dist_co_pearson), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_pearson_ward.D2_co)

IoA_pearson_single_co<- d(as.matrix(coph_dist_co_pearson_single), as.matrix(dist_co_pearson), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_pearson_single_co)

IoA_pearson_average_co<- d(as.matrix(coph_dist_co_pearson_average), as.matrix(dist_co_pearson), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_pearson_average_co)

IoA_pearson_centroid_co<- d(as.matrix(coph_dist_co_pearson_centroid), as.matrix(dist_co_pearson), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_pearson_centroid_co)


## Manhattan
IoA_manhattan_complete_co<- d(as.matrix(coph_dist_co_manhattan_complete), as.matrix(dist_co_manhattan), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_manhattan_complete_co)

IoA_manhattan_ward.D2_co<- d(as.matrix(coph_dist_co_manhattan_ward.D2), as.matrix(dist_co_manhattan), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_manhattan_ward.D2_co)

IoA_manhattan_single_co<- d(as.matrix(coph_dist_co_manhattan_single), as.matrix(dist_co_manhattan), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_manhattan_single_co)

IoA_manhattan_average_co<- d(as.matrix(coph_dist_co_manhattan_average), as.matrix(dist_co_manhattan), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_manhattan_average_co)

IoA_manhattan_centroid_co<- d(as.matrix(coph_dist_co_manhattan_centroid), as.matrix(dist_co_manhattan), na.rm = FALSE)
df_IoA_coz<- cbind(df_IoA_coz, IoA_manhattan_centroid_co)

```


```{r}
#A<- as.data.frame(t(df_IoA_coz))
#A<- A %>% rownames_to_column(var = "rownames")
#write_tsv(A, "IoA_co.tsv")
```


Los mejores: spearman, pearson, euclidean con average. Spearman y pearson con complete tambien muy bien, no tanto pero muy bien.



### 3.4.4. Dendrograms



```{r}
## For example
fviz_dend(hc_co_1_average, 
          main = "Jaccard - Average", 
          xlab = "",  ylab = "", 
          cex = 0.8,
          horiz = TRUE) 
          #k = 25, k_colors = palette_Vi_25) +
  #geom_hline(yintercept = 0.79, linetype = "dashed")

```



# 4. Datos NX



## 4.1. Import data


```{r}
# 76 cell types
df_NX_original<- read_tsv("rna_single_cell_type_version_2_1.tsv", show_col_types = FALSE)
colnames(df_NX_original)<- c("Gene", "Gene_name", "Cell_type", "NX") # change spaces with low bars
```


## 4.2. Data preparation


```{r}
# Check for missing data
any(is.na(df_NX_original))

# In case of TRUE, missing data must be removed or estimated
```


```{r}
## Declare variables
# Source: https://www.proteinatlas.org/humanproteome/single+cell+type
Adipocytes<-	c("adipocytes")
Blood_and_immune <-	c("t-cells", "b-cells", "plasma cells", "nk-cells", "granulocytes", "monocytes", "macrophages", "hofbauer cells", "kupffer cells", "dendritic cells", "langerhans cells", "erythroid cells")
Endocrine<- c("enteroendocrine cells", "pancreatic endocrine cells", "leydig cells", "theca cells")	
Endothelial <-	c("endothelial cells")
Germ<- c("spermatogonia", "spermatocytes", "early spermatids", "late spermatids")
Glandular_epithelial<- c("basal respiratory cells", "club cells", "ionocytes", "respiratory ciliated cells", "gastric mucus-secreting cells", "proximal enterocytes", "paneth cells", "distal enterocytes", "intestinal goblet cells", "exocrine glandular cells", "basal prostatic cells", "prostatic glandular cells", "breast glandular cells", "breast myoepithelial cells", "endometrial ciliated cells", "glandular and luminal cells")
Glial<- c("astrocytes", "oligodendrocyte precursor cells", "oligodendrocytes", "microglial cells", "muller glia cells")
Mesenchymal<- c("fibroblasts", "hepatic stellate cells", "peritubular cells", "endometrial stromal cells")
mixed_cell_types<- c("mixed cell types")
mixed_immune<- c("mixed immune cells")
Muscle <-	c("cardiomyocytes", "skeletal myocytes", "smooth muscle cells")
Neuronal<-	c("excitatory neurons", "inhibitory neurons", "cone photoreceptor cells", "rod photoreceptor cells", "bipolar cells", "horizontal cells")
Pigment <-	c("melanocytes")
Squamous_epithelial<-	c("basal keratinocytes", "suprabasal keratinocytes", "basal squamous epithelial cells", "squamous epithelial cells")	
Specialized_epithelial<-	c("alveolar cells type 1", "alveolar cells type 2", "ductal cells", "hepatocytes", "cholangiocytes", "proximal tubular cells", "distal tubular cells", "collecting duct cells", "urothelial cells", "sertoli cells", "granulosa cells")	
Trophoblast<-	c("cytotrophoblasts", "syncytiotrophoblasts", "extravillous trophoblasts")
Undifferentiated <-	c("undifferentiated cells")


# Function that creates and adds cell type group column
cell_type_group_column<- function(number_clusters, dataframe, number_column, name_dataframe) {
  
  cell_type_group<- c()
  
  for (i in seq(1:number_clusters)){
    
    example<- dataframe[i, number_column]
    
    if (example %in% Adipocytes) {
      cell_type_group<-c(cell_type_group,"Adipocytes")
      }
    
    else if (example %in% Blood_and_immune){
      cell_type_group<-c(cell_type_group,"Blood & immune")
      }
    
    else if (example %in% Endocrine){
      cell_type_group<-c(cell_type_group,"Endocrine cells")
      }
    
    else if (example %in% Endothelial){
      cell_type_group<-c(cell_type_group,"Endothelial cells")
      }
    
    else if (example %in% Glandular_epithelial){
      cell_type_group<-c(cell_type_group,"Glandular epithelial cells")
      }
    
    else if (example %in% Germ){
      cell_type_group<-c(cell_type_group,"Germ cells")
      }
    
    else if (example %in% Glial){
      cell_type_group<-c(cell_type_group,"Glial cells")
      }
    
    else if (example %in% Mesenchymal){
      cell_type_group<-c(cell_type_group,"Mesenchymal cells")
      }
    
    else if (example %in% mixed_cell_types){
      cell_type_group<-c(cell_type_group,"Mixed cell types")
      }
    
    else if (example %in% mixed_immune) {
      cell_type_group<-c(cell_type_group,"Mixed immune cells")
      }
    
    else if (example %in% Muscle) {
      cell_type_group<-c(cell_type_group,"Muscle cells")
      }
    
    else if (example %in% Neuronal) {
      cell_type_group<-c(cell_type_group,"Neuronal cells")
    }
    
    else if (example %in% Pigment) {
      cell_type_group<-c(cell_type_group,"Pigment cells")
    }
    
     else if (example %in% Squamous_epithelial) {
      cell_type_group<-c(cell_type_group,"Squamous epithelial cells")
    }
    
    else if (example %in% Specialized_epithelial) {
      cell_type_group<-c(cell_type_group,"Specialized epithelial cells")
    }
    
     else if (example %in% Trophoblast) {
      cell_type_group<-c(cell_type_group,"Trophoblasts")
     }
    
      else if (example %in% Undifferentiated) {
      cell_type_group<-c(cell_type_group,"Undifferentiated")
    }
    
    cell_type_group<<- cell_type_group
    
  }

  outside<<- cbind(data.frame("Cell_type_group" = cell_type_group, dataframe[,1:length(dataframe),drop=F]))
  assign(name_dataframe, outside, envir = .GlobalEnv)
}
```


## 4.3. Generate data


```{r}
## Data frame: rows = observations (cell types) and columns = variables (genes)

# Create data frame of one column (Cell_type)
df_NX<- data.frame(df_NX_original$Cell_type[1:76]) # dim(76,1)

# Add gene columns to it:
start<-1
end<-76

for (i in unique(df_NX_original$Gene_name)){
    i<-as.list(df_NX_original[start:end,4])
    df_NX<- cbind(df_NX,i) 
    start= start+76
    end=end+76
}

# Name columns
colnames(df_NX)<-c("Cell_type", unique(df_NX_original$Gene_name))

# Name rows
rownames(df_NX)<- df_NX$Cell_type

# Convert cell type names into lower case
df_NX<- transform(df_NX, Cell_type=tolower(Cell_type))

# Add column "cell type group" 
cell_type_group_column(number_clusters=76, dataframe=df_NX, number_column=1, name_dataframe="df_NX")
```


## 4.4. Basic data exploration


```{r}
# Dimensions
cat(bold("Dimensions: \n\n"), bold("Rows: "), nrow(df_NX_original), "\n", bold("Columns: "), ncol(df_NX_original), "\n\n")

# Information about cell types
celltypes <- df_NX_original$Cell_type
unique_celltypes <- unique(celltypes)
cat(bold("Number of cell types: "), length(unique_celltypes), "\n\n")
cat(bold("Cell types: "), paste0(unique_celltypes, collapse=", "), "\n\n")


# Information about genes
genes<-df_NX_original$Gene_name
unique_genes <- unique(genes)
cat(bold("Number of genes: "), length(unique_genes), "\n\n")


# Information about clusters
# A cluster consists of several cells grouped together because they have similar gene expression pattern
# All genes have the same number of clusters per tissue
clusters <- df_NX_original %>% subset(Gene_name == "VIM") # for example, VIM
cat(bold("Number of clusters: "), nrow(clusters), "\n\n")
# 76 clusters
```


```{r}
## Rename rows

ct_lower<- tolower(unique_celltypes)

replaced<- str_replace_all(ct_lower, fixed(" "), "_")
replaced<- str_replace_all(replaced, fixed("-"), "_")

replaced<- replaced[-22] # remove'ductal_cells'
replaced<- append(replaced, "pancreatic_ductal_cells", after = 21) # add correct name

rownames(df_NX)<- replaced

which(replaced == 'pancreatic_ductal_cells') # check that it has been added in the same index
```


```{r}
df_NX_filtered<- df_NX %>% filter(row.names(df_NX) %in% names(terms))
```


```{r}
# Split data
df_NX_data <- select(df_NX, -Cell_type, -Cell_type_group)
df_NX_target<- select(df_NX, Cell_type, Cell_type_group)
df_NX_genes<- as.data.frame(t(df_NX_data))
```


```{r}
# See if there is any gene whose expression is invariant among the clusters

length(which(apply(df_NX_data, 2, function(x) length(unique(x))) == 1))
# returns number of columns which has number of unique values equal to 1, meaning that has the same value (invariant genes)

# Store their names
genes_discarded<- names(which(apply(df_NX_data, 2, function(x) length(unique(x))) == 1))
```


```{r}
dim(df_NX_data)
```


```{r}
# I guess that the invariant genes corresponds to genes that does not express in any cluster
# I'll remove those genes cause they don't get us any useful information

#df_NX_data<- df_NX_data[, colSums(df_NX_data != 0) > 0]
df_NX_data <- df_NX_data[, ! names(df_NX_data) %in% genes_discarded, drop = F]

# check that all genes removed corresponds to genes with 0 expression
dim(df_NX_data)
```


```{r}
## Obtain proper data frame: rows = observations (genes) and columns = variables (cell types)
df_pTPM_genes<- as.data.frame(t(df_NX_data))

#write.csv(df_pTPM_genes, "df_pTPM_genes.csv")
```


```{r}
# Filter cell types to be left just with the ones present in Vickarious
df_NX_data<- df_NX_data %>% filter(row.names(df_NX_data) %in% names(terms))
```




## 4.5. Hierarchical clustering



```{r}
## Data preparation

## With the following code I calculate:
# Distances (dist)
# Hierarchical tree (hc)
# Cophenetic correlation coefficient (corr_list)


metrics_NX<- c("euclidean", "manhattan",  "pearson", "spearman")
methods_NX<- c("ward.D2", "single", "complete", "average", "centroid")

corr_list_NX<- c()
ID_NX<- c()


for(i in seq_along(metrics_NX)) {
  
  if (metrics_NX[i] == "euclidean") {
    
    # Compute distance matrix
    dist<- get_dist(scale(df_NX_data), method = metrics_NX[i])
  
    # Save it into a variable
    name_dist<- paste("dist_NX", metrics_NX[i], sep="_", collapse=NULL) 
    assign(name_dist, dist, envir = .GlobalEnv)
  }
  
  else {
    # Compute distance matrix
    dist<- get_dist(df_NX_data, method = metrics_NX[i])
  
    # Save it into a variable
    name_dist<- paste("dist_NX", metrics_NX[i], sep="_", collapse=NULL) 
    assign(name_dist, dist, envir = .GlobalEnv)
  }
    

  for(j in seq_along(methods_NX)) {
    
    # Cluster data in a hierarchical tree according to distance matrix
    hc <- hclust(d = dist, method = methods_NX[j])
   
    # Save it into a variable
    name_hc<- paste("hc_NX", metrics_NX[i], methods_NX[j], sep="_", collapse=NULL) 
    assign(name_hc, hc, envir = .GlobalEnv)
    
    # Save names
    ID_NX<- c(ID_NX, name_hc)
    
    # Create
    dend<- as.dendrogram(hc)
    
    # Save it into a variable
    name_dend<- paste("dend_NX", metrics_NX[i], methods_NX[j], sep="_", collapse=NULL) 
    assign(name_dend, dend, envir = .GlobalEnv)

    # Compute cophentic distance (Coph. dist.) matrix, represents dissimilarity between instances in the dendrogram
    # Coph. dist. between two instances is defined as the height in the dendrogram where two instances are joined for the first time
    coph.dist<- cophenetic(hc)
    
    # Save it into a variable
    name_coph.dist<- paste("coph_dist_NX", metrics_NX[i], methods_NX[j], sep="_", collapse=NULL) 
    assign(name_coph.dist, coph.dist, envir = .GlobalEnv)
    
    # Correlation between cophenetic distance and the original distance
    corr<- cor(dist, coph.dist)
    
    # Add correlations to a list
    corr_list_NX<-c(corr_list_NX, corr)
    
    cat(metrics_NX[i], "&", methods_NX[j], "->",corr , "\n\n")
    
    }
}
```



### 4.5.1. Distance matrix cell types


The classification of observations into groups requires some methods for computing the distance or the (dis)similarity between each pair of observations. The result of this computation is known as a dissimilarity or distance matrix.


```{r}
# Visualize all distance matrices (euclidean, manhattan, pearson, spearman, maximum, canberra)

dm1<- fviz_dist(dist_NX_euclidean, show_labels = FALSE) + labs(title = "Euclidean")
dm2<- fviz_dist(dist_NX_manhattan, show_labels = FALSE) + labs(title = "Manhattan")
dm3<- fviz_dist(dist_NX_pearson, show_labels = FALSE) + labs(title = "Pearson")
dm4<- fviz_dist(dist_NX_spearman, show_labels = FALSE) + labs(title = "Spearman")
```


```{r}
figure<- ggarrange(dm1, dm2, dm3, dm4,
          ncol = 3, nrow = 2)

annotate_figure(figure,
                top = text_grob("", size = 1),
                bottom = text_grob("\nData source: Karlsson et al. (2021)", hjust = 1, x = 1, face = "italic", size = 20),
                fig.lab = "", fig.lab.face = "bold",  fig.lab.size=1
                )
```

Euclidean, Maximum y Manhattan no parecen distinguir muy bien los grupos. 

Trabajaré con Spearman y Pearson.


```{r}
# Calculate melted distance matrix
melted_dm1<- melt(as.matrix(dist_NX_euclidean))
melted_dm2<- melt(as.matrix(dist_NX_manhattan))
melted_dm3<- melt(as.matrix(dist_NX_pearson))
melted_dm4<- melt(as.matrix(dist_NX_spearman))
```


```{r}
# For example
#tiff("Euclidean_NX.tiff",width=3840,height=2160)

fviz_dist(dist_NX_euclidean, show_labels = FALSE) + 
  theme(axis.text.x=element_text(colour="grey20",size=30, angle = 90, hjust = 1, vjust=0.5),
        axis.text.y=element_text(colour="grey20", size=30, hjust=1)) +
  labs(x = "", y = "") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  theme(legend.position="none")

#dev.off()
```



### 4.5.2. Cophenetic correlation coefficient (Rohlf, 1962)


```{r}
# Employ cophentic correlation to identify which of the linkage methods mentioned above produces the dendrogram with the highest similarity to the underlying distance matrix.

df_corr_NX <- data.frame(ID_NX, corr_list_NX)

# The numbers are indeed of type character. I need to convert them to numeric
df_corr_NX<- transform(df_corr_NX,corr_list_NX = as.numeric(corr_list_NX)) 

# Order from greater to smaller CoCC value
df_corr_NX<- arrange(df_corr_NX, desc(corr_list_NX)) 


## According to Rohlf (1988):
# very good = >0.9
# good = 0.8 - 0.9
# reasonably good = 0.7 - 0.8

Target<- c()

for (i in seq_along(corr_list_NX)){
  
  if (df_corr_NX$corr_list_NX[i] > 0.9) {
    Target<- c(Target, "Very good")
  } 
  
  if (df_corr_NX$corr_list_NX[i] > 0.8 & df_corr_NX$corr_list_NX[i] <= 0.9) {
    Target<- c(Target, "Good")
  } 
  
  if (df_corr_NX$corr_list_NX[i] > 0.7 & df_corr_NX$corr_list_NX[i] <= 0.8) {
    Target<- c(Target, "Reasonably good")
  } 
  
  if (df_corr_NX$corr_list_NX[i] <= 0.7) {
    Target<- c(Target, "Not good")
  }
}

# Add target column
df_corr_NX<- cbind(df_corr_NX, Target)
df_corr_NX<- transform(df_corr_NX, Target=as.factor(Target))

# See default levels order:
levels(df_corr_NX$Target) 
# "Good", "Not good", "Reasonably good", "Very good" 

# Specify the factor levels in the order I want
df_corr_NX$Target <- factor(df_corr_NX$Target, levels = c("Very good", "Good", "Reasonably good", "Not good"))
```
Once the dendrogram is created, we can evaluate whether its structure reflects the original distances between observations or not. This can be done by calculating the correlation coefficient between the cophenetic distances of the dendrogram and the original distance matrix. The cophentic distance between two instances is defined as the height in the dendrogram where two instances are joined for the first time, that is, the height of the nodes.

```{r}
# Visualize best coph corr

ggplot(df_corr_NX, aes(x=reorder(ID_NX, -corr_list_NX), y=corr_list_NX, fill=Target)) + 
  geom_bar(stat="identity", size=1) + 
  scale_fill_manual(values=c("deeppink", "deeppink4", "brown", "gray")) +
  theme(axis.text.x=element_text(colour="grey20",size=15),
        axis.text.y=element_text(colour="grey20", hjust=1,vjust=0.8,size=10),
        axis.title.x=element_text(colour="grey20", size=20),
        axis.title.y=element_text(colour="grey20", size=20)) +
  labs(x = "Hierarchical tree\n\n", y = "\n\nCophenetic correlation coefficient\n\n") + 

  theme(legend.position= "bottom",
        legend.text=element_text(size=14),
        legend.title=element_text(size=14)) +
  guides(fill=guide_legend(title="Rohlf (1988)",keywidth = 2, keyheight = 1, title.position = "left", title.hjust = -0.1)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line=element_line(colour = "black", size = 0.7, linetype = "solid")) +
  theme(axis.ticks.y = element_line(color = c(NA)),
        axis.ticks.x = element_line(color = c(NA))) +
  coord_flip()
```



### 4.5.3. Index of Agreement



```{r}
# A value of 1 indicates a perfect match, and 0 indicates no agreement at all


# Euclidean

IoA_euclidean_complete_NX<- d(as.matrix(coph_dist_NX_euclidean_complete), as.matrix(dist_NX_euclidean), na.rm = FALSE)
df_IoA_NXz<- data.frame(IoA_euclidean_complete_NX)

IoA_euclidean_ward.D2_NX<- d(as.matrix(coph_dist_NX_euclidean_ward.D2), as.matrix(dist_NX_euclidean), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_euclidean_ward.D2_NX)

IoA_euclidean_single_NX<- d(as.matrix(coph_dist_NX_euclidean_single), as.matrix(dist_NX_euclidean), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_euclidean_single_NX)

IoA_euclidean_average_NX<- d(as.matrix(coph_dist_NX_euclidean_average), as.matrix(dist_NX_euclidean), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_euclidean_average_NX)
                                              
IoA_euclidean_centroid_NX<- d(as.matrix(coph_dist_NX_euclidean_centroid), as.matrix(dist_NX_euclidean), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_euclidean_centroid_NX)


## Spearman

IoA_spearman_complete_NX<- d(as.matrix(coph_dist_NX_spearman_complete), as.matrix(dist_NX_spearman), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_spearman_complete_NX)

IoA_spearman_ward.D2_NX<- d(as.matrix(coph_dist_NX_spearman_ward.D2), as.matrix(dist_NX_spearman), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_spearman_ward.D2_NX)

IoA_spearman_single_NX<- d(as.matrix(coph_dist_NX_spearman_single), as.matrix(dist_NX_spearman), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_spearman_single_NX)

IoA_spearman_average_NX<- d(as.matrix(coph_dist_NX_spearman_average), as.matrix(dist_NX_spearman), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_spearman_average_NX)

IoA_spearman_centroid_NX<- d(as.matrix(coph_dist_NX_spearman_centroid), as.matrix(dist_NX_spearman), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_spearman_centroid_NX)


## Pearson
IoA_pearson_complete_NX<- d(as.matrix(coph_dist_NX_pearson_complete), as.matrix(dist_NX_pearson), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_pearson_complete_NX)

IoA_pearson_ward.D2_NX<- d(as.matrix(coph_dist_NX_pearson_ward.D2), as.matrix(dist_NX_pearson), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_pearson_ward.D2_NX)

IoA_pearson_single_NX<- d(as.matrix(coph_dist_NX_pearson_single), as.matrix(dist_NX_pearson), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_pearson_single_NX)

IoA_pearson_average_NX<- d(as.matrix(coph_dist_NX_pearson_average), as.matrix(dist_NX_pearson), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_pearson_average_NX)

IoA_pearson_centroid_NX<- d(as.matrix(coph_dist_NX_pearson_centroid), as.matrix(dist_NX_pearson), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_pearson_centroid_NX)


## Manhattan
IoA_manhattan_complete_NX<- d(as.matrix(coph_dist_NX_manhattan_complete), as.matrix(dist_NX_manhattan), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_manhattan_complete_NX)

IoA_manhattan_ward.D2_NX<- d(as.matrix(coph_dist_NX_manhattan_ward.D2), as.matrix(dist_NX_manhattan), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_manhattan_ward.D2_NX)

IoA_manhattan_single_NX<- d(as.matrix(coph_dist_NX_manhattan_single), as.matrix(dist_NX_manhattan), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_manhattan_single_NX)

IoA_manhattan_average_NX<- d(as.matrix(coph_dist_NX_manhattan_average), as.matrix(dist_NX_manhattan), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_manhattan_average_NX)

IoA_manhattan_centroid_NX<- d(as.matrix(coph_dist_NX_manhattan_centroid), as.matrix(dist_NX_manhattan), na.rm = FALSE)
df_IoA_NXz<- cbind(df_IoA_NXz, IoA_manhattan_centroid_NX)

```


--> Euclidean, Average


### 4.5.4. Internal validation


```{r}
set.seed(31)

## The Elbow plot

# This plot only takes into account the Within-cluster sum of squares (SSW), a measure of the cohesion of the clusters (the greater the cohesion, the smaller the SSW)
# It assumes that we want clusters to be as compact (high cohesion, high separation) as possible.
# The optimal number of clusters is chosen at the point where if we increase the number of clusters, the SSW improves notably less than in the previous step. In other words, we should choose a number of clusters where adding an extra cluster doesn't improve much the performance (in terms of SSW) of the clustering algorithm.
fviz_nbclust(df_NX_data, kmeans, method = "wss", k.max = 40) + theme_minimal() + ggtitle("the Elbow Method")

# The point at k = 3 is the point with the largest reduction in improvement afterwards (from k = 2 to k = 3 there has been a much greater improvement than comparing to the one going from k = 3 to k = 4), so this could be considered the elbow.
#Thus, according to the elbow plot (which takes into account the SSW), the optimal k is 3.

# After k=8 there is barely improvement, what leads to think that it has no sense to cluster data in more than 8 groups. After k=3, the number of clusters 4, 5 and 6 seem to be reasonably  better than 7, 8 and so on.



## The Silhouette Plot

#The best score is for k = 2  and again  k = 3 (silhouette score aprox. 0.85). This is very high, considering the maximum for the silhouette score is 1. So the clusters are very compact and separated.
# The other much smaller pick at k=7 has a score of aprox. 0.25, which is very low.
fviz_nbclust(df_NX_data, kmeans, method = "silhouette", k.max = 40) + theme_minimal() + ggtitle("The Silhouette Plot")
```



#### 4.5.4.1. Dendograms

```{r}
#For example

fviz_dend(hc_NX_euclidean_average, 
          main = "Euclidean - Average", 
          xlab = "",  ylab = "", 
          cex = 0.8, 
          horiz = TRUE, 
          k = 3, k_colors = palette_Vi_25) +
  geom_hline(yintercept = 0.95, linetype = "dashed")

```




# 5. Comparison


```{r}
sorted_df_NX<- df_NX_data[order(row.names(df_NX_data)), ]
sorted_df_Vi<- df_VH[order(row.names(df_VH)), ] 
sorted_df_Co<- df_CellOntoloy[order(row.names(df_CellOntoloy)), ] 

sorted_dist_NX<- get_dist(sorted_df_NX, method = "pearson") # Genes
sorted_dist_Vi<- dist.binary(sorted_df_Vi, method = 5) # Vickarious
sorted_dist_Co<- dist.binary(sorted_df_Co, method = 1) # Cell Ontology

sorted_hc_NX <- hclust(d = sorted_dist_NX, method = "complete")
sorted_hc_Vi <- hclust(d = sorted_dist_Vi, method = "complete")
sorted_hc_Co <- hclust(d = sorted_dist_Co, method = "single")

sorted_dend_NX<- as.dendrogram(sorted_hc_NX)
sorted_dend_Vi<- as.dendrogram(sorted_hc_Vi)
sorted_dend_Co<- as.dendrogram(sorted_hc_Co)
```



```{r}
dend_list_1 <- dendlist("Gene data" = sorted_dend_NX, 
                      " Cell Ontology" = sorted_dend_Co )

tanglegram(sorted_dend_NX, sorted_dend_Co,
           highlight_distinct_edges = TRUE, # dashed lines
           common_subtrees_color_lines = TRUE, # line colors
           common_subtrees_color_branches = TRUE, # Color common branches
           main = paste("entanglement =", round(entanglement(dend_list_1), 2)),
           sort=TRUE,
           )
```


```{r}
cors<- cor.dendlist(dend_list_1, method = "cophenetic") # method = "baker"
corrplot(round(cors, 2), "pie", "lower")
```


```{r}
# https://search.r-project.org/CRAN/refmans/dendextend/html/tanglegram.html

dend_list_3 <- dendlist(
                        "Gene data" = sorted_dend_NX,
                        "Vickarious" = sorted_dend_Vi)
# Note that "unique" nodes, with a combination of labels/items not present in the other tree, are highlighted with dashed lines.
tanglegram(sorted_dend_NX,sorted_dend_Vi,
           highlight_distinct_edges = TRUE, # dashed lines
           common_subtrees_color_lines = TRUE, # line colors
           common_subtrees_color_branches = TRUE, # Color common branches
           main = paste("entanglement =", round(entanglement(dend_list_3), 2)),
           sort=TRUE
           )

```


```{r}
cors<- cor.dendlist(dend_list_3, method = "cophenetic") # method = "baker"
corrplot(round(cors, 2), "pie", "lower")
```



```{r}
# Create multiple dendrograms by chaining
dend_list_3 <- dendlist("genes" = sorted_dend_NX,
                        "Vick" =sorted_dend_Vi,
                        "CO" =sorted_dend_Co)

cors<- cor.dendlist(dend_list_3, method = "cophenetic") # method = "baker"
corrplot(round(cors, 3), "pie", "lower")


round(cors, 3)
```


```{r}
dm1<- fviz_dist(dist_NX_pearson, show_labels = FALSE) + labs(title = "Genetic")
dm2<- fviz_dist(dist_Vi_5, show_labels = FALSE) + labs(title = "Histo/Cytological")
dm3<- fviz_dist(dist_co_1, show_labels = FALSE) + labs(title = "Ontological")

```



```{r}
# Visualize all distance matrices ("euclidean", "Dice/Sorensen", "Jaccard", "Ochiai")

dm_1<- fviz_dist(dist_NX_pearson, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Genetic")


dm_2<- fviz_dist(dist_Vi_5, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Histo/Cytological")


dm_3<- fviz_dist(dist_co_1, show_labels = TRUE, gradient = list(low = "#0000FF", mid = "#FFFF00", high = "#FF0000")) + # blue, yellow, red
  theme(text = element_text(size = 15, face = "bold"),
        axis.text = element_text(size = 7.5)) +
labs(title = "Ontological")



figure<- ggarrange(dm_1, dm_1, dm_1,
          ncol = 3, nrow = 1)


annotate_figure(figure
                
                )
```


```{r}
pvalue<- c()
mantel_r<- c()

mantel_function<- function(my_dist1, my_dist2) {
  
  mantel_test<-  mantel(my_dist1, my_dist2, method = "spearman", permutations = 9999, na.rm = TRUE)
  
  A<- mantel_test$signif
  pvalue<<-c(pvalue, A)
  
  B<- mantel_test$statistic
  mantel_r<<- c(mantel_r, B)
}



mantel_function(sorted_dist_NX, sorted_dist_Co)
mantel_function(sorted_dist_NX, sorted_dist_Vi)
mantel_function(sorted_dist_Vi, sorted_dist_Co)
```


```{r}
ID_mantel<- c("NX vs CO", "NX vs Vi", "Vi vs CO")

# Create data frame with mantel test information
df_mantel <- data.frame(ID_mantel, mantel_r, pvalue)

# The numbers are indeed of type character. I need to convert them to numeric
df_mantel<- transform(df_mantel,mantel_r = as.numeric(mantel_r)) 
df_mantel<- transform(df_mantel,pvalue = as.numeric(pvalue)) 
```



